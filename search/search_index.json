{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FlowStack SDK","text":""},{"location":"#from-local-agent-to-production-in-5-minutes","title":"From Local Agent to Production in 5 Minutes","text":"<p>Build your AI agent locally. Deploy with one command. Get a production endpoint instantly.</p> <ul> <li> <p> 5 Minutes to Production</p> <p>Skip weeks of infrastructure setup. Build locally, deploy instantly.</p> <pre><code>agent.deploy()  # That's it\n</code></pre> </li> <li> <p> Built-in Persistence</p> <p>DataVault gives every agent MongoDB-backed storage with zero configuration.</p> <pre><code>agent.vault.store('users', data)\n</code></pre> </li> <li> <p> Simple Billing</p> <p>Pay per session (API call), not per token. No surprise bills.</p> <p>Free: 25 sessions/month | Hobbyist: $15/200 sessions</p> </li> <li> <p> Auto-Scaling Infrastructure</p> <p>We handle Lambda, containers, databases. You focus on agent logic.</p> <p>From 0 to 1000s of requests automatically.</p> </li> </ul>"},{"location":"#the-problem","title":"The Problem","text":"<p>You can build an AI agent locally in 10 minutes. Deploying it to production takes 10 days of DevOps hell:</p> <ul> <li>\u274c Setting up AWS Lambda functions</li> <li>\u274c Configuring Docker containers</li> <li>\u274c Managing databases and persistence</li> <li>\u274c Setting up API gateways and load balancers</li> <li>\u274c Handling authentication and security</li> <li>\u274c Managing scaling and monitoring</li> </ul>"},{"location":"#the-flowstack-solution","title":"The FlowStack Solution","text":"<pre><code>from flowstack import Agent\n\n# 1. Build your agent locally\nagent = Agent(\"customer-helper\", api_key=\"fs_...\")\n\n@agent.tool\ndef lookup_order(order_id: str):\n    \"\"\"Check order status in your system\"\"\"\n    # Your business logic here\n    return {\"status\": \"shipped\", \"tracking\": \"UPS123456\"}\n\n# 2. Test locally (works on your machine)\nresponse = agent.chat(\"What's the status of order 12345?\")\nprint(response)\n\n# 3. Deploy to production (one command)\nendpoint = agent.deploy()\nprint(f\"Live at: {endpoint}\")\n# \u2192 https://api.flowstack.fun/agents/customer-helper\n\n# 4. Your agent is now live and accessible via API\n</code></pre> <p>That's it. Your agent is now running in production with:</p> <p>\u2705 HTTPS API endpoint - Ready for production traffic \u2705 Automatic scaling - From 0 to thousands of requests \u2705 Built-in persistence - DataVault for storing data \u2705 Security &amp; isolation - Each agent runs securely \u2705 Monitoring &amp; logs - Track usage and debug issues  </p>"},{"location":"#who-this-is-for","title":"Who This Is For","text":""},{"location":"#indie-developers-hackers","title":"Indie Developers &amp; Hackers","text":"<p>You're building side projects, prototypes, or internal tools. Pain point: You can hack something locally, but deploying sucks.</p> <p>Weekend Project</p> <p>Build a Slack bot, Discord assistant, or automation tool. Deploy Sunday night, use Monday morning.</p>"},{"location":"#startups-exploring-ai","title":"Startups Exploring AI","text":"<p>You don't want to spend weeks on infrastructure when testing ideas. Value: FlowStack = shortcut to shipping production-ready agents.</p> <p>MVP in Days</p> <p>Test your AI product idea with real users. Iterate on features, not infrastructure.</p>"},{"location":"#automation-enthusiasts","title":"Automation Enthusiasts","text":"<p>You're already using Zapier or n8n. Value: Agents + persistence + real runtime \u2192 more powerful than simple automation.</p> <p>Zapier Killer</p> <p>Build stateful workflows that remember context between runs. Handle complex decision trees.</p>"},{"location":"#what-we-handle-so-you-dont-have-to","title":"What We Handle (So You Don't Have To)","text":"<ul> <li> <p> Infrastructure</p> <p>Lambda functions, Docker containers, auto-scaling, load balancing</p> </li> <li> <p> Persistence</p> <p>MongoDB-backed DataVault with namespaced, isolated storage</p> </li> <li> <p> AI Access</p> <p>Managed Bedrock, OpenAI, Anthropic with simple provider switching</p> </li> <li> <p> Security</p> <p>API authentication, request isolation, rate limiting, monitoring</p> </li> <li> <p> Monitoring</p> <p>Usage tracking, error handling, debugging tools, real-time logs</p> </li> <li> <p> Billing</p> <p>Transparent session-based pricing, usage tracking, no hidden fees</p> </li> </ul>"},{"location":"#ready-to-start","title":"Ready to Start?","text":"<ul> <li> <p> 5-Minute Quickstart</p> <p>Build and deploy your first agent in under 5 minutes</p> </li> <li> <p> Core Concepts</p> <p>Understand agents, deployment, DataVault, and sessions</p> </li> <li> <p> Recipes &amp; Examples</p> <p>Real-world examples for chatbots, automation, and workflows</p> </li> </ul> <p>The Vision</p> <p>FlowStack is the Vercel for AI agents. You build the logic, we handle everything else to make it production-ready. Skip the infrastructure grind \u2014 focus on what makes your agent unique.</p> <p>Get Started \u2192</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete reference for the FlowStack Python SDK.</p>"},{"location":"api-reference/#agent-class","title":"Agent Class","text":""},{"location":"api-reference/#flowstack.agent.Agent","title":"flowstack.agent.Agent","text":"<p>AI Agent with clean customer interface</p> <p>Handles multiple providers, billing, and BYOK scenarios without exposing internal markup or payment flow details</p>"},{"location":"api-reference/#flowstack.agent.Agent.__init__","title":"__init__","text":"<pre><code>__init__(name: str, api_key: str, provider: str = Providers.BEDROCK, model: str = Models.CLAUDE_35_SONNET, byok: Optional[Dict[str, str]] = None, base_url: str = None, **kwargs)\n</code></pre> <p>Initialize FlowStack Agent</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Agent name/identifier</p> required <code>api_key</code> <code>str</code> <p>FlowStack API key</p> required <code>provider</code> <code>str</code> <p>AI provider (bedrock, openai, anthropic, etc.)</p> <code>BEDROCK</code> <code>model</code> <code>str</code> <p>Model to use</p> <code>CLAUDE_35_SONNET</code> <code>byok</code> <code>Optional[Dict[str, str]]</code> <p>Bring Your Own Key credentials (optional)</p> <code>None</code> <code>base_url</code> <code>str</code> <p>API base URL (optional)</p> <code>None</code> <code>**kwargs</code> <p>Additional configuration</p> <code>{}</code>"},{"location":"api-reference/#flowstack.agent.Agent.invoke","title":"invoke","text":"<pre><code>invoke(message: Union[str, List[Dict[str, str]]], **kwargs) -&gt; Dict[str, Any]\n</code></pre> <p>Send a message to the AI model</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Union[str, List[Dict[str, str]]]</code> <p>Text message or list of message objects</p> required <code>**kwargs</code> <p>Additional parameters (temperature, max_tokens, etc.)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Model response</p>"},{"location":"api-reference/#flowstack.agent.Agent.chat","title":"chat","text":"<pre><code>chat(message: str, **kwargs) -&gt; str\n</code></pre> <p>Simple chat interface - returns just the text response</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>User message</p> required <code>**kwargs</code> <p>Additional parameters</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>AI response text</p>"},{"location":"api-reference/#flowstack.agent.Agent.set_model","title":"set_model","text":"<pre><code>set_model(model: str)\n</code></pre> <p>Change the model being used</p>"},{"location":"api-reference/#flowstack.agent.Agent.set_provider","title":"set_provider","text":"<pre><code>set_provider(provider: str, byok: Optional[Dict[str, str]] = None)\n</code></pre> <p>Change the provider and optionally update BYOK credentials</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>New provider to use</p> required <code>byok</code> <code>Optional[Dict[str, str]]</code> <p>BYOK credentials (if required)</p> <code>None</code>"},{"location":"api-reference/#flowstack.agent.Agent.get_usage","title":"get_usage","text":"<pre><code>get_usage() -&gt; UsageStats\n</code></pre> <p>Get current usage statistics</p>"},{"location":"api-reference/#flowstack.agent.Agent.store_byok_credentials","title":"store_byok_credentials","text":"<pre><code>store_byok_credentials(provider: str, credentials: Dict[str, str]) -&gt; bool\n</code></pre> <p>Store BYOK credentials for future use</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>str</code> <p>Provider name</p> required <code>credentials</code> <code>Dict[str, str]</code> <p>Credential dictionary</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Success status</p>"},{"location":"api-reference/#flowstack.agent.Agent.get_tier_info","title":"get_tier_info","text":"<pre><code>get_tier_info() -&gt; Dict[str, Any]\n</code></pre> <p>Get information about current tier</p>"},{"location":"api-reference/#usage-examples","title":"Usage Examples","text":""},{"location":"api-reference/#basic-agent-creation","title":"Basic Agent Creation","text":"<pre><code>from flowstack import Agent, Models, Providers\n\n# Simple agent with defaults\nagent = Agent(\n    name=\"my-agent\",\n    api_key=\"fs_your_api_key_here\"\n)\n\n# Agent with specific provider and model\nagent = Agent(\n    name=\"openai-agent\", \n    api_key=\"fs_your_api_key_here\",\n    provider=Providers.OPENAI,\n    model=\"gpt-4o\",\n    byok={\"api_key\": \"sk-your-openai-key\"}\n)\n</code></pre>"},{"location":"api-reference/#adding-tools","title":"Adding Tools","text":"<pre><code>@agent.tool\ndef get_weather(city: str) -&gt; dict:\n    \"\"\"Get current weather for a city\"\"\"\n    # Your implementation here\n    return {\"city\": city, \"temperature\": 72, \"condition\": \"sunny\"}\n\n@agent.tool\ndef send_email(to: str, subject: str, body: str) -&gt; dict:\n    \"\"\"Send an email\"\"\"\n    # Your implementation here\n    return {\"sent\": True, \"message_id\": \"abc123\"}\n</code></pre>"},{"location":"api-reference/#chat-interface","title":"Chat Interface","text":"<pre><code># Simple chat\nresponse = agent.chat(\"What's the weather in San Francisco?\")\nprint(response)\n\n# Chat with parameters\nresponse = agent.chat(\n    \"Write a haiku about programming\",\n    temperature=0.8,\n    max_tokens=100\n)\n</code></pre>"},{"location":"api-reference/#advanced-usage","title":"Advanced Usage","text":"<pre><code># Multi-turn conversation\nmessages = [\n    {\"role\": \"user\", \"content\": \"What is Python?\"},\n    {\"role\": \"assistant\", \"content\": \"Python is a programming language...\"},\n    {\"role\": \"user\", \"content\": \"Show me an example\"}\n]\n\nresponse = agent.invoke(messages, temperature=0.7)\n</code></pre>"},{"location":"api-reference/#methods","title":"Methods","text":""},{"location":"api-reference/#__init__name-api_key-providerprovidersbedrock-modelmodelsclaude_35_sonnet-byoknone-base_urlnone-kwargs","title":"<code>__init__(name, api_key, provider=Providers.BEDROCK, model=Models.CLAUDE_35_SONNET, byok=None, base_url=None, **kwargs)</code>","text":"<p>Initialize a new FlowStack agent.</p> <p>Parameters:</p> <ul> <li><code>name</code> (str): Unique identifier for your agent</li> <li><code>api_key</code> (str): Your FlowStack API key</li> <li><code>provider</code> (str): AI provider to use (default: Providers.BEDROCK)</li> <li><code>model</code> (str): Model to use (default: Models.CLAUDE_35_SONNET)  </li> <li><code>byok</code> (dict, optional): Bring Your Own Key credentials</li> <li><code>base_url</code> (str, optional): Custom API base URL</li> <li><code>**kwargs</code>: Additional configuration options</li> </ul> <p>Example: <pre><code>agent = Agent(\n    name=\"customer-service\",\n    api_key=\"fs_abc123\",\n    provider=Providers.OPENAI,\n    model=\"gpt-4o\",\n    byok={\"api_key\": \"sk-xyz789\"}\n)\n</code></pre></p>"},{"location":"api-reference/#chatmessage-kwargs-str","title":"<code>chat(message, **kwargs) -&gt; str</code>","text":"<p>Simple chat interface that returns just the text response.</p> <p>Parameters:</p> <ul> <li><code>message</code> (str): Your message to the agent</li> <li><code>**kwargs</code>: Additional parameters (temperature, max_tokens, etc.)</li> </ul> <p>Returns: <code>str</code> - The agent's response</p> <p>Example: <pre><code>response = agent.chat(\"Hello! How are you?\")\nprint(response)  # \"Hello! I'm doing well, thank you for asking...\"\n</code></pre></p>"},{"location":"api-reference/#invokemessage-kwargs-dict","title":"<code>invoke(message, **kwargs) -&gt; dict</code>","text":"<p>Advanced interface for full control over the conversation.</p> <p>Parameters:</p> <ul> <li><code>message</code> (str | list): Text message or list of message objects</li> <li><code>**kwargs</code>: Additional parameters (temperature, max_tokens, etc.)</li> </ul> <p>Returns: <code>dict</code> - Full response object with metadata</p> <p>Example: <pre><code># Simple message\nresponse = agent.invoke(\"Tell me a joke\")\n\n# Multi-turn conversation\nmessages = [\n    {\"role\": \"user\", \"content\": \"What is AI?\"},\n    {\"role\": \"assistant\", \"content\": \"AI stands for Artificial Intelligence...\"},\n    {\"role\": \"user\", \"content\": \"Give me an example\"}\n]\nresponse = agent.invoke(messages)\n</code></pre></p>"},{"location":"api-reference/#deploy-str","title":"<code>deploy() -&gt; str</code>","text":"<p>Deploy your agent to production.</p> <p>Returns: <code>str</code> - Production endpoint URL</p> <p>Example: <pre><code>endpoint = agent.deploy()\nprint(f\"Agent deployed at: {endpoint}\")\n# Output: \"Agent deployed at: https://api.flowstack.fun/agents/my-agent\"\n</code></pre></p>"},{"location":"api-reference/#get_usage-usagestats","title":"<code>get_usage() -&gt; UsageStats</code>","text":"<p>Get current usage statistics and limits.</p> <p>Returns: <code>UsageStats</code> - Usage information object</p> <p>Example: <pre><code>usage = agent.get_usage()\nprint(f\"Sessions: {usage.sessions_used}/{usage.sessions_limit}\")\nprint(f\"Remaining: {usage.sessions_remaining}\")\nprint(f\"Usage: {usage.usage_percentage:.1f}%\")\n\nif usage.is_near_limit:\n    print(\"Warning: Approaching usage limit!\")\n</code></pre></p>"},{"location":"api-reference/#set_providerprovider-byoknone","title":"<code>set_provider(provider, byok=None)</code>","text":"<p>Switch to a different AI provider.</p> <p>Parameters:</p> <ul> <li><code>provider</code> (str): New provider to use</li> <li><code>byok</code> (dict, optional): BYOK credentials if required</li> </ul> <p>Example: <pre><code># Switch to OpenAI\nagent.set_provider(Providers.OPENAI, byok={\"api_key\": \"sk-...\"})\n\n# Switch to Anthropic\nagent.set_provider(Providers.ANTHROPIC, byok={\"api_key\": \"sk-ant-...\"})\n\n# Switch back to managed Bedrock\nagent.set_provider(Providers.BEDROCK)\n</code></pre></p>"},{"location":"api-reference/#set_modelmodel","title":"<code>set_model(model)</code>","text":"<p>Change the model being used.</p> <p>Parameters:</p> <ul> <li><code>model</code> (str): New model to use</li> </ul> <p>Example: <pre><code>agent.set_model(\"gpt-4o\")\nagent.set_model(Models.CLAUDE_35_HAIKU)\n</code></pre></p>"},{"location":"api-reference/#get_tier_info-dict","title":"<code>get_tier_info() -&gt; dict</code>","text":"<p>Get information about your current pricing tier.</p> <p>Returns: <code>dict</code> - Tier information</p> <p>Example: <pre><code>tier = agent.get_tier_info()\nprint(f\"Current tier: {tier['current_tier']}\")\nprint(f\"Session limit: {tier['session_limit']}\")\nprint(f\"Can use managed models: {tier['can_use_managed']}\")\n</code></pre></p>"},{"location":"api-reference/#store_byok_credentialsprovider-credentials-bool","title":"<code>store_byok_credentials(provider, credentials) -&gt; bool</code>","text":"<p>Store BYOK credentials for future use.</p> <p>Parameters:</p> <ul> <li><code>provider</code> (str): Provider name</li> <li><code>credentials</code> (dict): Credential dictionary</li> </ul> <p>Returns: <code>bool</code> - Success status</p> <p>Example: <pre><code>success = agent.store_byok_credentials('openai', {\n    'api_key': 'sk-your-openai-key'\n})\n\nif success:\n    print(\"Credentials stored successfully\")\n</code></pre></p>"},{"location":"api-reference/#properties","title":"Properties","text":""},{"location":"api-reference/#vault","title":"<code>vault</code>","text":"<p>Access to DataVault for persistent storage.</p> <p>Example: <pre><code># Store data\nagent.vault.store('users', {'name': 'Alice', 'age': 30})\n\n# Retrieve data\nuser = agent.vault.retrieve('users', key='user_123')\n\n# Query data\nadults = agent.vault.query('users', {'age': {'$gte': 18}})\n</code></pre></p>"},{"location":"api-reference/#datavault","title":"DataVault","text":"<p>The DataVault provides persistent storage for your agents.</p>"},{"location":"api-reference/#core-methods","title":"Core Methods","text":""},{"location":"api-reference/#storecollection-data-keynone-str","title":"<code>store(collection, data, key=None) -&gt; str</code>","text":"<p>Store data in a collection.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name (like a database table)</li> <li><code>data</code> (dict): Data to store</li> <li><code>key</code> (str, optional): Custom key (auto-generated if not provided)</li> </ul> <p>Returns: <code>str</code> - Key of stored item</p> <p>Example: <pre><code># Auto-generated key\nkey = agent.vault.store('products', {\n    'name': 'Laptop',\n    'price': 999.99,\n    'category': 'electronics'\n})\n\n# Custom key\nagent.vault.store('products', {\n    'name': 'Mouse',\n    'price': 29.99\n}, key='mouse-001')\n</code></pre></p>"},{"location":"api-reference/#retrievecollection-keynone-filternone-dict-list-none","title":"<code>retrieve(collection, key=None, filter=None) -&gt; dict | list | None</code>","text":"<p>Retrieve data from a collection.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name</li> <li><code>key</code> (str, optional): Specific key to retrieve</li> <li><code>filter</code> (dict, optional): Query filter for multiple items</li> </ul> <p>Returns: Single item, list of items, or None</p> <p>Example: <pre><code># Get specific item\nproduct = agent.vault.retrieve('products', key='mouse-001')\n\n# Get all items in collection\nall_products = agent.vault.retrieve('products')\n\n# Query with filter\nexpensive_items = agent.vault.retrieve('products', filter={\n    'price': {'$gte': 500}\n})\n</code></pre></p>"},{"location":"api-reference/#querycollection-filternone-sortnone-limitnone-list","title":"<code>query(collection, filter=None, sort=None, limit=None) -&gt; list</code>","text":"<p>Advanced querying with MongoDB-style filters.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name</li> <li><code>filter</code> (dict, optional): Query filter</li> <li><code>sort</code> (list, optional): Sort specification</li> <li><code>limit</code> (int, optional): Maximum number of results</li> </ul> <p>Returns: <code>list</code> - List of matching items</p> <p>Example: <pre><code># Basic query\nresults = agent.vault.query('users', {'age': {'$gte': 18}})\n\n# Query with sorting and limiting\nrecent_orders = agent.vault.query('orders',\n    filter={'status': 'completed'},\n    sort=[('created_at', -1)],  # Descending\n    limit=10\n)\n\n# Complex query\npower_users = agent.vault.query('users', {\n    '$or': [\n        {'premium': True},\n        {'login_count': {'$gte': 100}}\n    ]\n})\n</code></pre></p>"},{"location":"api-reference/#updatecollection-key-updates-bool","title":"<code>update(collection, key, updates) -&gt; bool</code>","text":"<p>Update an existing item.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name</li> <li><code>key</code> (str): Key of item to update</li> <li><code>updates</code> (dict): Fields to update</li> </ul> <p>Returns: <code>bool</code> - Success status</p> <p>Example: <pre><code>success = agent.vault.update('products', 'mouse-001', {\n    'price': 24.99,\n    'sale': True\n})\n</code></pre></p>"},{"location":"api-reference/#deletecollection-key-bool","title":"<code>delete(collection, key) -&gt; bool</code>","text":"<p>Delete an item from a collection.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name</li> <li><code>key</code> (str): Key of item to delete</li> </ul> <p>Returns: <code>bool</code> - Success status</p> <p>Example: <pre><code>deleted = agent.vault.delete('products', 'mouse-001')\n</code></pre></p>"},{"location":"api-reference/#countcollection-filternone-int","title":"<code>count(collection, filter=None) -&gt; int</code>","text":"<p>Count items in a collection.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name</li> <li><code>filter</code> (dict, optional): Query filter</li> </ul> <p>Returns: <code>int</code> - Number of items</p> <p>Example: <pre><code>total_users = agent.vault.count('users')\nactive_users = agent.vault.count('users', {'active': True})\n</code></pre></p>"},{"location":"api-reference/#list_collections-list","title":"<code>list_collections() -&gt; list</code>","text":"<p>List all collections in your agent's namespace.</p> <p>Returns: <code>list</code> - Collection names</p> <p>Example: <pre><code>collections = agent.vault.list_collections()\nprint(f\"Available collections: {collections}\")\n</code></pre></p>"},{"location":"api-reference/#clearcollection-bool","title":"<code>clear(collection) -&gt; bool</code>","text":"<p>Clear all items from a collection.</p> <p>Destructive Operation</p> <p>This permanently deletes all data in the collection.</p> <p>Parameters:</p> <ul> <li><code>collection</code> (str): Collection name</li> </ul> <p>Returns: <code>bool</code> - Success status</p> <p>Example: <pre><code># Clear temporary cache\nagent.vault.clear('temp_cache')\n</code></pre></p>"},{"location":"api-reference/#usagestats-class","title":"UsageStats Class","text":""},{"location":"api-reference/#flowstack.billing.UsageStats","title":"flowstack.billing.UsageStats","text":"<p>Clean representation of usage statistics Hides internal billing calculations from customer</p>"},{"location":"api-reference/#flowstack.billing.UsageStats.usage_percentage","title":"usage_percentage  <code>property</code>","text":"<pre><code>usage_percentage: float\n</code></pre> <p>Get usage as percentage of limit</p>"},{"location":"api-reference/#flowstack.billing.UsageStats.is_near_limit","title":"is_near_limit  <code>property</code>","text":"<pre><code>is_near_limit: bool\n</code></pre> <p>Check if usage is near the limit (&gt;80%)</p>"},{"location":"api-reference/#flowstack.billing.UsageStats.can_make_requests","title":"can_make_requests  <code>property</code>","text":"<pre><code>can_make_requests: bool\n</code></pre> <p>Check if more requests can be made</p>"},{"location":"api-reference/#properties_1","title":"Properties","text":""},{"location":"api-reference/#sessions_used","title":"<code>sessions_used</code>","text":"<p>Number of sessions used in current billing period.</p>"},{"location":"api-reference/#sessions_limit","title":"<code>sessions_limit</code>","text":"<p>Total session limit for current billing period.</p>"},{"location":"api-reference/#sessions_remaining","title":"<code>sessions_remaining</code>","text":"<p>Number of sessions remaining.</p>"},{"location":"api-reference/#current_charges","title":"<code>current_charges</code>","text":"<p>Current charges for the billing period.</p>"},{"location":"api-reference/#tier","title":"<code>tier</code>","text":"<p>Current pricing tier (free, starter, professional, enterprise).</p>"},{"location":"api-reference/#usage_percentage","title":"<code>usage_percentage</code>","text":"<p>Usage as percentage of limit (0-100).</p>"},{"location":"api-reference/#is_near_limit","title":"<code>is_near_limit</code>","text":"<p>True if usage is above 80% of limit.</p>"},{"location":"api-reference/#can_make_requests","title":"<code>can_make_requests</code>","text":"<p>True if more requests can be made within limits.</p>"},{"location":"api-reference/#example-usage","title":"Example Usage","text":"<pre><code>usage = agent.get_usage()\n\nprint(f\"Usage: {usage.sessions_used}/{usage.sessions_limit}\")\nprint(f\"Percentage: {usage.usage_percentage:.1f}%\")\nprint(f\"Current charges: ${usage.current_charges:.2f}\")\nprint(f\"Tier: {usage.tier}\")\n\nif usage.is_near_limit:\n    print(\"\u26a0\ufe0f Warning: You're using 80%+ of your monthly sessions\")\n\nif not usage.can_make_requests:\n    print(\"\u274c Session limit reached. Please upgrade your plan.\")\n\nprint(f\"Sessions remaining: {usage.sessions_remaining}\")\n</code></pre>"},{"location":"api-reference/#constants","title":"Constants","text":""},{"location":"api-reference/#models","title":"Models","text":"<pre><code>from flowstack import Models\n\n# Anthropic Claude (via Bedrock)\nModels.CLAUDE_35_SONNET      # claude-3-5-sonnet-20240620-v1:0\nModels.CLAUDE_35_HAIKU       # claude-3-5-haiku-20240307-v1:0  \nModels.CLAUDE_3_OPUS         # claude-3-opus-20240229-v1:0\n\n# Meta Llama (via Bedrock)\nModels.LLAMA_3_70B           # meta.llama3-70b-instruct-v1:0\nModels.LLAMA_31_405B         # meta.llama3-1-405b-instruct-v1:0\n\n# OpenAI (BYOK only)\nModels.GPT_4O                # gpt-4o\nModels.GPT_4_TURBO           # gpt-4-turbo\nModels.GPT_35_TURBO          # gpt-3.5-turbo\n</code></pre>"},{"location":"api-reference/#providers","title":"Providers","text":"<pre><code>from flowstack import Providers\n\n# Managed billing available\nProviders.BEDROCK            # AWS Bedrock (managed or BYOK)\n\n# BYOK only\nProviders.OPENAI             # OpenAI API\nProviders.ANTHROPIC          # Anthropic API  \nProviders.COHERE             # Cohere API\nProviders.MISTRAL            # Mistral AI API\nProviders.OLLAMA             # Local Ollama\nProviders.SAGEMAKER          # AWS SageMaker\nProviders.WRITER             # Writer API\n</code></pre>"},{"location":"api-reference/#exceptions","title":"Exceptions","text":""},{"location":"api-reference/#flowstackerror","title":"FlowStackError","text":"<p>Base exception for all FlowStack SDK errors.</p> <pre><code>from flowstack import FlowStackError\n\ntry:\n    response = agent.chat(\"Hello\")\nexcept FlowStackError as e:\n    print(f\"FlowStack error: {e}\")\n</code></pre>"},{"location":"api-reference/#authenticationerror","title":"AuthenticationError","text":"<p>Raised when API key is invalid or missing.</p> <pre><code>from flowstack import AuthenticationError\n\ntry:\n    agent = Agent(\"test\", api_key=\"invalid_key\")\n    response = agent.chat(\"Hello\")\nexcept AuthenticationError as e:\n    print(f\"Authentication failed: {e}\")\n</code></pre>"},{"location":"api-reference/#quotaexceedederror","title":"QuotaExceededError","text":"<p>Raised when usage limits are exceeded.</p> <pre><code>from flowstack import QuotaExceededError\n\ntry:\n    response = agent.chat(\"Hello\")\nexcept QuotaExceededError as e:\n    print(f\"Quota exceeded: {e}\")\n    print(f\"Current usage: {e.details.get('current_usage')}\")\n    print(f\"Limit: {e.details.get('limit')}\")\n</code></pre>"},{"location":"api-reference/#invalidprovidererror","title":"InvalidProviderError","text":"<p>Raised when an unsupported provider is specified.</p> <pre><code>from flowstack import InvalidProviderError\n\ntry:\n    agent.set_provider(\"unsupported_provider\")\nexcept InvalidProviderError as e:\n    print(f\"Invalid provider: {e}\")\n</code></pre>"},{"location":"api-reference/#credentialsrequirederror","title":"CredentialsRequiredError","text":"<p>Raised when BYOK credentials are required but not provided.</p> <pre><code>from flowstack import CredentialsRequiredError\n\ntry:\n    agent = Agent(\"test\", api_key=\"fs_...\", provider=\"openai\")  # Missing BYOK\nexcept CredentialsRequiredError as e:\n    print(f\"Credentials required: {e}\")\n</code></pre>"},{"location":"api-reference/#tierlimitationerror","title":"TierLimitationError","text":"<p>Raised when trying to use features not available in current tier.</p> <pre><code>from flowstack import TierLimitationError\n\ntry:\n    response = agent.chat(\"Hello\")  # Free tier trying to use managed models\nexcept TierLimitationError as e:\n    print(f\"Tier limitation: {e}\")\n</code></pre>"},{"location":"api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api-reference/#create_agent","title":"create_agent()","text":"<p>Convenience function for quick agent creation.</p> <pre><code>from flowstack import create_agent, Models, Providers\n\nagent = create_agent(\n    name=\"quick-agent\",\n    api_key=\"fs_your_key\",\n    provider=Providers.OPENAI,\n    model=Models.GPT_4O,\n    byok={\"api_key\": \"sk-...\"}\n)\n</code></pre>"},{"location":"api-reference/#environment-variables","title":"Environment Variables","text":"<p>The SDK respects these environment variables:</p> <ul> <li><code>FLOWSTACK_API_URL</code>: Custom API base URL (default: https://api.flowstack.fun)</li> <li><code>FLOWSTACK_API_KEY</code>: Default API key (if not provided in constructor)</li> </ul> <pre><code>export FLOWSTACK_API_URL=\"https://api.flowstack.fun\"\nexport FLOWSTACK_API_KEY=\"fs_your_api_key_here\"\n</code></pre>"},{"location":"api-reference/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<pre><code>from flowstack import (\n    Agent, FlowStackError, AuthenticationError, \n    QuotaExceededError, CredentialsRequiredError\n)\n\ntry:\n    agent = Agent(\"my-agent\", api_key=\"fs_...\")\n\n    # Check usage before making requests\n    usage = agent.get_usage()\n    if not usage.can_make_requests:\n        print(\"Usage limit reached!\")\n        return\n\n    response = agent.chat(\"Hello!\")\n    print(response)\n\nexcept AuthenticationError:\n    print(\"Invalid API key. Please check your credentials.\")\n\nexcept QuotaExceededError as e:\n    print(f\"Usage limit exceeded: {e}\")\n    print(\"Please upgrade your plan or wait for reset.\")\n\nexcept CredentialsRequiredError as e:\n    print(f\"BYOK credentials required: {e}\")\n    print(\"Please provide API keys for the selected provider.\")\n\nexcept FlowStackError as e:\n    print(f\"FlowStack error: {e}\")\n\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre> <p>For more examples and detailed guides, see our recipes and concepts documentation.</p>"},{"location":"billing/","title":"Billing &amp; Usage","text":"<p>FlowStack uses simple, transparent pricing based on sessions. No complex token counting, no surprise bills.</p>"},{"location":"billing/#how-billing-works","title":"How Billing Works","text":""},{"location":"billing/#session-based-pricing","title":"Session-Based Pricing","text":"<p>A session is one API call to FlowStack, regardless of conversation length or message count:</p> <p>What Counts as One Session</p> <p>Each API call = One session:</p> <ul> <li>User: \"Hello, can you help me?\" \u2192 Session 1</li> <li>Agent: \"Of course! What do you need help with?\"</li> <li>User: \"I need to analyze this data...\" \u2192 Session 2</li> <li>Agent: \"I'll analyze that data for you. Here are the results...\"</li> <li>User: \"Thanks! Can you also create a chart?\" \u2192 Session 3</li> <li>Agent: \"Absolutely! Here's your chart...\"</li> </ul> <p>3 user messages = 3 sessions</p>"},{"location":"billing/#session-lifecycle","title":"Session Lifecycle","text":"<ul> <li>Each API request counts as one session</li> <li>No conversation memory - each call is independent</li> <li>Chatbots naturally use more sessions - each user message is a new session</li> <li>Maximum request duration: 5 minutes (Lambda timeout)</li> </ul>"},{"location":"billing/#pricing-tiers","title":"Pricing Tiers","text":"<ul> <li> <p> Free Tier</p> <p>$0/month</p> <ul> <li>25 sessions/month</li> <li>BYOK required for all providers</li> <li>No managed Bedrock access</li> <li>Community support</li> </ul> </li> <li> <p> Hobbyist</p> <p>$15/month</p> <ul> <li>200 sessions/month</li> <li>Managed Bedrock included</li> <li>BYOK optional for cost savings</li> <li>Email support</li> </ul> </li> <li> <p> Starter</p> <p>$50/month</p> <ul> <li>1,000 sessions/month</li> <li>Managed Bedrock included</li> <li>BYOK optional for cost savings</li> <li>Email support</li> </ul> </li> <li> <p> Professional</p> <p>$200/month</p> <ul> <li>5,000 sessions/month</li> <li>Optimized AI pricing</li> <li>Priority support</li> <li>Advanced analytics</li> </ul> </li> <li> <p> Enterprise</p> <p>Custom pricing</p> <ul> <li>25,000+ sessions/month</li> <li>Volume pricing discounts</li> <li>Custom infrastructure</li> <li>Dedicated support</li> </ul> </li> </ul>"},{"location":"billing/#understanding-costs","title":"Understanding Costs","text":""},{"location":"billing/#managed-vs-byok","title":"Managed vs BYOK","text":"<p>FlowStack offers two pricing models:</p>"},{"location":"billing/#managed-infrastructure","title":"Managed Infrastructure","text":"<pre><code># Managed Bedrock - included in session pricing\nagent = Agent(\n    name=\"managed-agent\",\n    api_key=\"fs_...\",\n    provider=\"bedrock\",  # Managed by FlowStack\n    model=\"claude-3-sonnet\"\n)\n</code></pre> <p>Benefits: - \u2705 No additional AI costs - \u2705 Optimized performance - \u2705 Simplified billing - \u2705 Enterprise SLA</p>"},{"location":"billing/#bring-your-own-keys-byok","title":"Bring Your Own Keys (BYOK)","text":"<pre><code># BYOK - you pay AI provider directly\nagent = Agent(\n    name=\"byok-agent\",\n    api_key=\"fs_...\",\n    provider=\"openai\",\n    model=\"gpt-4o\",\n    byok={\"api_key\": \"sk-your-openai-key\"}  # Your key\n)\n</code></pre> <p>Benefits: - \u2705 Direct AI provider billing - \u2705 No markup on AI costs - \u2705 Full control over AI spending - \u2705 Access to latest models</p>"},{"location":"billing/#cost-comparison-examples","title":"Cost Comparison Examples","text":""},{"location":"billing/#simple-chatbot-1000-sessionsmonth","title":"Simple Chatbot (1,000 sessions/month)","text":"Managed (Starter Plan)BYOK (Free + OpenAI)BYOK (Starter + GPT-3.5) <p>FlowStack: $29/month</p> <p>AI Costs: Included</p> <p>Total: $29/month</p> <p>\u2705 Predictable costs \u2705 No usage spikes \u2705 Enterprise reliability</p> <p>FlowStack: $0/month (if under 25 sessions) or $29/month</p> <p>OpenAI GPT-4: ~$75/month (estimated)</p> <p>Total: $75-104/month</p> <p>\u2705 Latest OpenAI models \u2705 Direct provider billing \u274c Higher total cost</p> <p>FlowStack: $29/month</p> <p>OpenAI GPT-3.5: ~$15/month (estimated)</p> <p>Total: $44/month</p> <p>\u2705 Lower AI costs \u2705 Good performance \u26a0\ufe0f Less capable model</p>"},{"location":"billing/#high-volume-application-10000-sessionsmonth","title":"High-Volume Application (10,000 sessions/month)","text":"Professional PlanBYOK Alternative <p>FlowStack: $99/month</p> <p>AI Costs: Included</p> <p>Total: $99/month</p> <p>\u2705 Best value for high volume \u2705 Optimized infrastructure \u2705 Priority support</p> <p>FlowStack: $99/month</p> <p>AI Provider: $300-800/month (estimated)</p> <p>Total: $399-899/month</p> <p>\u2705 Access to any model \u274c Much higher costs \u274c Complex billing management</p>"},{"location":"billing/#usage-tracking","title":"Usage Tracking","text":""},{"location":"billing/#check-your-usage","title":"Check Your Usage","text":"<pre><code>from flowstack import Agent\n\nagent = Agent(\"my-agent\", api_key=\"fs_...\")\n\n# Get current usage\nusage = agent.get_usage()\n\nprint(f\"Sessions used: {usage.sessions_used}\")\nprint(f\"Sessions limit: {usage.sessions_limit}\")\nprint(f\"Sessions remaining: {usage.sessions_remaining}\")\nprint(f\"Usage percentage: {usage.usage_percentage:.1f}%\")\nprint(f\"Current charges: ${usage.current_charges:.2f}\")\n</code></pre>"},{"location":"billing/#usage-alerts","title":"Usage Alerts","text":"<pre><code># Check if approaching limits\nusage = agent.get_usage()\n\nif usage.is_near_limit:\n    print(\"\u26a0\ufe0f Warning: You're using 80%+ of your monthly sessions\")\n\nif not usage.can_make_requests:\n    print(\"\u274c Session limit reached. Please upgrade your plan.\")\n\n# Get tier information\ntier_info = agent.get_tier_info()\nprint(f\"Current tier: {tier_info['current_tier']}\")\nprint(f\"Can use managed models: {tier_info['can_use_managed']}\")\n</code></pre>"},{"location":"billing/#usage-patterns","title":"Usage Patterns","text":"<pre><code># Track usage over time\n@agent.tool\ndef track_usage_patterns() -&gt; dict:\n    \"\"\"Track and analyze usage patterns\"\"\"\n\n    usage = agent.get_usage()\n\n    # Store usage snapshot\n    agent.vault.store('usage_history', {\n        'timestamp': datetime.now().isoformat(),\n        'sessions_used': usage.sessions_used,\n        'sessions_limit': usage.sessions_limit,\n        'usage_percentage': usage.usage_percentage,\n        'tier': usage.tier\n    })\n\n    # Get usage history for analysis\n    history = agent.vault.query('usage_history', \n        sort=[('timestamp', -1)], \n        limit=30  # Last 30 data points\n    )\n\n    # Calculate trends\n    if len(history) &gt;= 2:\n        recent_usage = history[0]['usage_percentage']\n        previous_usage = history[1]['usage_percentage']\n        trend = recent_usage - previous_usage\n    else:\n        trend = 0\n\n    return {\n        'current_usage': usage.usage_percentage,\n        'trend': trend,\n        'sessions_remaining': usage.sessions_remaining,\n        'days_left_in_period': calculate_days_remaining(),\n        'projected_usage': project_monthly_usage(history)\n    }\n</code></pre>"},{"location":"billing/#cost-optimization-strategies","title":"Cost Optimization Strategies","text":""},{"location":"billing/#1-choose-the-right-provider","title":"1. Choose the Right Provider","text":"<pre><code># Cost optimization based on task complexity\ndef optimize_provider_for_cost(task: str):\n    \"\"\"Choose provider based on cost and task complexity\"\"\"\n\n    complexity = analyze_task_complexity(task)\n\n    if complexity == \"simple\":\n        # Use cheapest option for simple tasks\n        agent.set_provider(\"openai\", byok={\"api_key\": \"sk-...\"})\n        agent.set_model(\"gpt-3.5-turbo\")  # ~$0.002 per 1K tokens\n\n    elif complexity == \"medium\":\n        # Use managed Bedrock for balanced cost/performance\n        agent.set_provider(\"bedrock\")  # Included in FlowStack pricing\n        agent.set_model(\"claude-3-sonnet\")\n\n    else:  # complex\n        # Use best model for complex tasks\n        agent.set_provider(\"anthropic\", byok={\"api_key\": \"sk-ant-...\"})\n        agent.set_model(\"claude-3-opus\")  # Most capable, higher cost\n</code></pre>"},{"location":"billing/#2-implement-smart-caching","title":"2. Implement Smart Caching","text":"<pre><code>@agent.tool\ndef cached_expensive_operation(query: str) -&gt; dict:\n    \"\"\"Cache expensive operations to reduce costs\"\"\"\n\n    # Generate cache key\n    cache_key = f\"expensive_op_{hash(query)}\"\n\n    # Check cache first\n    cached_result = agent.vault.retrieve('cache', key=cache_key)\n\n    if cached_result and not is_expired(cached_result):\n        return {\n            \"result\": cached_result['data'],\n            \"cached\": True,\n            \"cost_saved\": True\n        }\n\n    # Perform expensive operation\n    result = expensive_operation(query)\n\n    # Cache result for 1 hour\n    agent.vault.store('cache', {\n        'data': result,\n        'expires_at': (datetime.now() + timedelta(hours=1)).isoformat()\n    }, key=cache_key)\n\n    return {\n        \"result\": result,\n        \"cached\": False,\n        \"cost_saved\": False\n    }\n</code></pre>"},{"location":"billing/#3-batch-similar-requests","title":"3. Batch Similar Requests","text":"<pre><code>@agent.tool\ndef batch_processing(requests: list) -&gt; dict:\n    \"\"\"Process multiple similar requests in one session\"\"\"\n\n    results = []\n\n    # Process all requests in a single conversation\n    batch_prompt = \"Process these requests:\\n\"\n    for i, request in enumerate(requests):\n        batch_prompt += f\"{i+1}. {request}\\n\"\n\n    # Single AI call for multiple requests\n    response = agent.chat(batch_prompt)\n\n    # Parse batch response\n    parsed_results = parse_batch_response(response, len(requests))\n\n    return {\n        \"results\": parsed_results,\n        \"requests_processed\": len(requests),\n        \"sessions_used\": 1,  # Only one session for multiple requests\n        \"cost_efficiency\": f\"Processed {len(requests)} requests in 1 session\"\n    }\n</code></pre>"},{"location":"billing/#4-monitor-and-optimize","title":"4. Monitor and Optimize","text":"<pre><code>@agent.tool\ndef cost_analysis() -&gt; dict:\n    \"\"\"Analyze costs and suggest optimizations\"\"\"\n\n    # Get usage data\n    usage = agent.get_usage()\n\n    # Analyze provider usage patterns\n    provider_usage = agent.vault.query('provider_switches', \n        sort=[('timestamp', -1)], \n        limit=100\n    )\n\n    # Calculate cost breakdown\n    managed_sessions = len([p for p in provider_usage if p.get('provider') == 'bedrock'])\n    byok_sessions = len(provider_usage) - managed_sessions\n\n    recommendations = []\n\n    # Recommend based on usage patterns\n    if byok_sessions &gt; managed_sessions and usage.tier in ['starter', 'professional']:\n        recommendations.append({\n            'type': 'cost_reduction',\n            'message': 'You use BYOK frequently. Consider Professional plan for better managed pricing.',\n            'potential_savings': calculate_managed_savings(byok_sessions)\n        })\n\n    if usage.usage_percentage &lt; 50 and usage.tier != 'free':\n        recommendations.append({\n            'type': 'plan_optimization',\n            'message': 'You use less than 50% of your sessions. Consider downgrading.',\n            'potential_savings': calculate_downgrade_savings(usage.tier)\n        })\n\n    return {\n        'current_tier': usage.tier,\n        'usage_percentage': usage.usage_percentage,\n        'managed_sessions': managed_sessions,\n        'byok_sessions': byok_sessions,\n        'recommendations': recommendations,\n        'monthly_cost_estimate': estimate_monthly_cost(usage)\n    }\n</code></pre>"},{"location":"billing/#billing-faq","title":"Billing FAQ","text":""},{"location":"billing/#when-are-sessions-counted","title":"When are sessions counted?","text":"<p>Sessions are counted when your agent processes a message, not when tools are called or data is stored.</p> <pre><code># This counts as 1 session\nresponse = agent.chat(\"Hello, help me with a task\")\n\n# Even if the agent calls multiple tools\n@agent.tool  \ndef tool1(): pass\n\n@agent.tool\ndef tool2(): pass\n\n# And accesses DataVault multiple times\nagent.vault.store('data', {...})\nagent.vault.retrieve('data', key='...')\n</code></pre>"},{"location":"billing/#how-do-conversations-work","title":"How do conversations work?","text":"<p>Each API call is a separate session:</p> <pre><code># Session 1\nagent.chat(\"Hello\")  \n\n# Session 2 (new API call)\nagent.chat(\"Can you help me?\")\n\n# Session 3 (new API call)\nagent.chat(\"Thanks!\")\n\n# Session 4 (new API call)\nagent.chat(\"New question\")\n\n# Result: 4 API calls = 4 sessions total\n</code></pre>"},{"location":"billing/#what-happens-when-i-exceed-limits","title":"What happens when I exceed limits?","text":"<p>When you reach your session limit:</p> <ol> <li>Graceful degradation - Existing conversations can finish</li> <li>New sessions blocked - New conversations return quota exceeded error</li> <li>Tools still work - Agent tools and DataVault remain accessible</li> <li>Automatic reset - Limits reset at the start of your next billing cycle</li> </ol> <pre><code>try:\n    response = agent.chat(\"Hello\")\nexcept QuotaExceededError as e:\n    print(f\"Quota exceeded: {e}\")\n    print(f\"Current usage: {e.details['current_usage']}\")\n    print(f\"Limit: {e.details['limit']}\")\n    print(\"Please upgrade your plan or wait for reset.\")\n</code></pre>"},{"location":"billing/#how-do-refunds-work","title":"How do refunds work?","text":"<ul> <li>Unused sessions don't roll over - Use them or lose them each month</li> <li>Downgrades apply next cycle - Immediate downgrades aren't prorated  </li> <li>Upgrades are immediate - Extra sessions available instantly</li> <li>Cancellations effective at period end - Service continues until renewal date</li> </ul>"},{"location":"billing/#can-i-monitor-costs-in-real-time","title":"Can I monitor costs in real-time?","text":"<p>Yes! FlowStack provides real-time usage tracking:</p> <pre><code># Real-time usage monitoring\nusage = agent.get_usage()\nprint(f\"Sessions used today: {usage.sessions_used}\")\nprint(f\"Estimated monthly cost: ${estimate_monthly_cost(usage)}\")\n\n# Set up usage alerts\nif usage.usage_percentage &gt; 80:\n    send_slack_alert(f\"\u26a0\ufe0f Usage at {usage.usage_percentage}%\")\n</code></pre>"},{"location":"billing/#managing-costs","title":"Managing Costs","text":""},{"location":"billing/#set-usage-alerts","title":"Set Usage Alerts","text":"<pre><code>@agent.tool\ndef setup_usage_alerts(alert_thresholds: list = [75, 90, 95]) -&gt; dict:\n    \"\"\"Set up automated usage alerts\"\"\"\n\n    usage = agent.get_usage()\n\n    alerts_triggered = []\n\n    for threshold in alert_thresholds:\n        if usage.usage_percentage &gt;= threshold:\n            alert = {\n                'threshold': threshold,\n                'current_usage': usage.usage_percentage,\n                'sessions_remaining': usage.sessions_remaining,\n                'message': f'Usage alert: {usage.usage_percentage}% of monthly limit reached'\n            }\n            alerts_triggered.append(alert)\n\n            # Send alert (integrate with your notification system)\n            send_usage_alert(alert)\n\n    return {\n        'current_usage': usage.usage_percentage,\n        'alerts_triggered': alerts_triggered,\n        'next_reset': get_next_billing_cycle_date()\n    }\n</code></pre>"},{"location":"billing/#budget-management","title":"Budget Management","text":"<pre><code>@agent.tool\ndef budget_guard(max_monthly_cost: float) -&gt; dict:\n    \"\"\"Prevent exceeding monthly budget\"\"\"\n\n    usage = agent.get_usage()\n    estimated_cost = estimate_monthly_cost(usage)\n\n    if estimated_cost &gt; max_monthly_cost:\n        return {\n            'error': 'Budget exceeded',\n            'estimated_monthly_cost': estimated_cost,\n            'budget_limit': max_monthly_cost,\n            'recommendation': 'Consider optimizing usage or increasing budget'\n        }\n\n    return {\n        'budget_status': 'within_limits',\n        'estimated_monthly_cost': estimated_cost,\n        'budget_limit': max_monthly_cost,\n        'budget_remaining': max_monthly_cost - estimated_cost\n    }\n</code></pre> <p>Questions about billing? Check our API reference for usage tracking methods or see production tips for cost optimization strategies.</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>Understanding the key concepts behind FlowStack will help you build better agents and make the most of the platform.</p>"},{"location":"concepts/#agent","title":"Agent","text":"<p>An Agent is your AI assistant with custom capabilities and memory.</p> <pre><code>from flowstack import Agent\n\nagent = Agent(\n    name=\"my-assistant\",        # Unique identifier\n    api_key=\"fs_your_key\",      # Your FlowStack API key  \n    provider=\"bedrock\",         # AI provider (bedrock, openai, anthropic)\n    model=\"claude-3-sonnet\"     # Specific model to use\n)\n</code></pre>"},{"location":"concepts/#what-makes-an-agent-unique","title":"What Makes an Agent Unique?","text":"<ul> <li>Tools: Custom functions the agent can call</li> <li>Memory: Persistent storage via DataVault</li> <li>Identity: Each agent has its own namespace and endpoint</li> <li>Behavior: The agent learns to use tools to complete tasks</li> </ul> <p>Agent Personality</p> <pre><code>agent = Agent(\n    name=\"helpful-assistant\",\n    api_key=\"fs_...\",\n    system_prompt=\"You are a helpful customer service agent. Always be polite and try to solve problems using the available tools.\"\n)\n</code></pre>"},{"location":"concepts/#tools","title":"Tools","text":"<p>Tools are Python functions that give your agent capabilities beyond chat.</p> <pre><code>@agent.tool\ndef get_weather(city: str) -&gt; dict:\n    \"\"\"Get current weather for a city\"\"\"\n    # Your implementation here\n    return {\"city\": city, \"temp\": 72, \"condition\": \"sunny\"}\n\n@agent.tool\ndef send_email(to: str, subject: str, body: str) -&gt; dict:\n    \"\"\"Send an email to a user\"\"\"\n    # Integration with email service\n    return {\"sent\": True, \"message_id\": \"abc123\"}\n</code></pre>"},{"location":"concepts/#tool-guidelines","title":"Tool Guidelines","text":"<p>Good Tools</p> <ul> <li>Single purpose: One tool = one clear function</li> <li>Clear docstrings: The agent uses these to understand what the tool does</li> <li>Return structured data: Dicts and lists work best</li> <li>Handle errors gracefully: Return error messages, don't raise exceptions</li> </ul> <p>Avoid</p> <ul> <li>Complex multi-step tools: Break them into smaller tools</li> <li>Missing docstrings: The agent won't know what the tool does</li> <li>Side effects without returns: Always return something meaningful</li> </ul>"},{"location":"concepts/#tool-examples-by-use-case","title":"Tool Examples by Use Case","text":"E-commerceCustomer SupportData Analysis <pre><code>@agent.tool\ndef lookup_order(order_id: str) -&gt; dict:\n    \"\"\"Get order details by ID\"\"\"\n    pass\n\n@agent.tool\ndef cancel_order(order_id: str) -&gt; dict:\n    \"\"\"Cancel an order if cancellation is allowed\"\"\"\n    pass\n\n@agent.tool\ndef process_refund(order_id: str, amount: float) -&gt; dict:\n    \"\"\"Process a refund for an order\"\"\"\n    pass\n</code></pre> <pre><code>@agent.tool\ndef search_knowledge_base(query: str) -&gt; list:\n    \"\"\"Search for relevant help articles\"\"\"\n    pass\n\n@agent.tool\ndef create_ticket(title: str, description: str, priority: str) -&gt; dict:\n    \"\"\"Create a support ticket\"\"\"\n    pass\n\n@agent.tool\ndef escalate_to_human(reason: str) -&gt; dict:\n    \"\"\"Escalate conversation to human agent\"\"\"\n    pass\n</code></pre> <pre><code>@agent.tool\ndef query_database(sql: str) -&gt; list:\n    \"\"\"Execute a SQL query safely\"\"\"\n    pass\n\n@agent.tool\ndef generate_chart(data: list, chart_type: str) -&gt; dict:\n    \"\"\"Create a chart from data\"\"\"\n    pass\n\n@agent.tool\ndef export_report(data: dict, format: str) -&gt; dict:\n    \"\"\"Export data as PDF or Excel\"\"\"\n    pass\n</code></pre>"},{"location":"concepts/#deployment","title":"Deployment","text":"<p>Deployment transforms your local agent into a production API with one command.</p> <pre><code># Deploy your agent\nendpoint = agent.deploy()\n# Returns: https://api.flowstack.fun/agents/your-agent-name\n</code></pre>"},{"location":"concepts/#what-happens-during-deployment","title":"What Happens During Deployment?","text":"<ol> <li>Code Packaging: Your agent code and tools are packaged</li> <li>Infrastructure Setup: Lambda functions, API Gateway, databases</li> <li>Endpoint Creation: Your agent gets a unique HTTPS URL</li> <li>Health Checks: We verify everything is working</li> <li>Go Live: Your agent starts handling requests</li> </ol>"},{"location":"concepts/#deployment-environments","title":"Deployment Environments","text":"DevelopmentProduction <pre><code>agent.deploy(environment=\"dev\")\n# \u2192 https://api.flowstack.fun/agents/your-agent-dev\n</code></pre> <ul> <li>Lower costs, higher limits for testing</li> <li>Separate DataVault namespace</li> <li>Faster iteration, more debugging info</li> </ul> <pre><code>agent.deploy(environment=\"prod\")\n# \u2192 https://api.flowstack.fun/agents/your-agent\n</code></pre> <ul> <li>Production SLA and monitoring</li> <li>Optimized performance</li> <li>Enhanced security and isolation</li> </ul> <p>Deploy Early and Often</p> <p>Deploy to dev environment frequently during development. Deploy to production when you're confident in your agent's behavior.</p>"},{"location":"concepts/#datavault","title":"DataVault","text":"<p>DataVault is persistent storage built into every agent. Think of it as a simple database that just works.</p> <pre><code># Store data\nkey = agent.vault.store('users', {\n    'name': 'Alice',\n    'preferences': {'theme': 'dark', 'notifications': True}\n})\n\n# Retrieve data\nuser = agent.vault.retrieve('users', key=key)\n\n# Query data\nrecent_users = agent.vault.query('users', {\n    'created_at': {'$gte': '2024-01-01'}\n})\n</code></pre>"},{"location":"concepts/#datavault-collections","title":"DataVault Collections","text":"<p>Think of collections like database tables. Each agent can create multiple collections:</p> <ul> <li><code>users</code> - User profiles and preferences</li> <li><code>conversations</code> - Chat history and context</li> <li><code>sessions</code> - Temporary session data</li> <li><code>feedback</code> - User feedback and ratings</li> <li><code>cache</code> - Temporary calculations or API responses</li> </ul>"},{"location":"concepts/#when-to-use-datavault","title":"When to Use DataVault","text":"<p>Perfect For</p> <ul> <li>User preferences and settings</li> <li>Conversation history and context</li> <li>Agent memory and learning</li> <li>Application state between sessions</li> <li>Caching expensive operations</li> </ul> <p>Not Designed For</p> <ul> <li>Large files or media (use cloud storage URLs)</li> <li>Real-time updates (not a message queue)</li> <li>Complex relational queries (use a proper database)</li> <li>Secrets or API keys (use BYOK for credentials)</li> </ul>"},{"location":"concepts/#datavault-patterns","title":"DataVault Patterns","text":"User StateConversation MemoryAgent Learning <pre><code>@agent.tool\ndef remember_preference(user_id: str, key: str, value: str):\n    \"\"\"Remember a user preference\"\"\"\n    user = agent.vault.retrieve('users', key=user_id) or {}\n    user.setdefault('preferences', {})[key] = value\n    agent.vault.store('users', user, key=user_id)\n    return f\"I'll remember that you prefer {key}: {value}\"\n\n@agent.tool\ndef get_user_preference(user_id: str, key: str):\n    \"\"\"Get a user's preference\"\"\"\n    user = agent.vault.retrieve('users', key=user_id) or {}\n    return user.get('preferences', {}).get(key, \"No preference set\")\n</code></pre> <pre><code>def store_conversation(user_id: str, messages: list):\n    \"\"\"Store conversation history\"\"\"\n    agent.vault.store('conversations', {\n        'user_id': user_id,\n        'messages': messages,\n        'timestamp': datetime.now().isoformat()\n    })\n\ndef get_conversation_history(user_id: str, limit: int = 10):\n    \"\"\"Get recent conversations for context\"\"\"\n    return agent.vault.query('conversations', \n        {'user_id': user_id},\n        sort=[('timestamp', -1)],\n        limit=limit\n    )\n</code></pre> <pre><code>@agent.tool\ndef learn_from_feedback(topic: str, feedback: str, helpful: bool):\n    \"\"\"Learn from user feedback\"\"\"\n    learning_data = {\n        'topic': topic,\n        'feedback': feedback,\n        'helpful': helpful,\n        'timestamp': datetime.now().isoformat()\n    }\n    agent.vault.store('learning', learning_data)\n    return \"Thank you for the feedback! I'll use this to improve.\"\n\ndef get_learned_patterns(topic: str):\n    \"\"\"Retrieve learning patterns for a topic\"\"\"\n    return agent.vault.query('learning', {\n        'topic': topic,\n        'helpful': True\n    })\n</code></pre>"},{"location":"concepts/#sessions","title":"Sessions","text":"<p>A session is FlowStack's billing unit. One session = one conversation (multiple messages back and forth).</p>"},{"location":"concepts/#session-lifecycle","title":"Session Lifecycle","text":"<ol> <li>Start: First message from a user starts a session</li> <li>Continue: Follow-up messages extend the same session  </li> <li>End: Session ends after 30 minutes of inactivity</li> <li>Bill: You're charged for one session regardless of message count</li> </ol> <pre><code># Check your usage\nusage = agent.get_usage()\nprint(f\"Sessions used: {usage.sessions_used}/{usage.sessions_limit}\")\nprint(f\"Usage percentage: {usage.usage_percentage:.1f}%\")\n\n# Check if you're near limits\nif usage.is_near_limit:\n    print(\"Warning: You're using 80%+ of your monthly sessions\")\n\nif not usage.can_make_requests:\n    print(\"Session limit reached. Please upgrade your plan.\")\n</code></pre>"},{"location":"concepts/#session-vs-messages","title":"Session vs. Messages","text":"<p>Session Counting</p> <p>One Session includes:</p> <ul> <li>User: \"What's the weather?\"</li> <li>Agent: \"I'll check that for you. Which city?\"</li> <li>User: \"San Francisco\"</li> <li>Agent: \"It's 72\u00b0F and sunny in San Francisco\"</li> <li>User: \"Thanks!\"</li> <li>Agent: \"You're welcome!\"</li> </ul> <p>Six messages = One session</p>"},{"location":"concepts/#managing-session-costs","title":"Managing Session Costs","text":"<ul> <li>Batch interactions: Handle multiple requests in one conversation</li> <li>Use DataVault: Store data instead of repeating context</li> <li>BYOK for AI costs: Use your own provider keys to avoid markup</li> <li>Monitor usage: Check <code>agent.get_usage()</code> regularly</li> </ul>"},{"location":"concepts/#ai-providers","title":"AI Providers","text":"<p>FlowStack supports multiple AI providers, giving you flexibility and control over costs.</p>"},{"location":"concepts/#managed-providers-flowstack-hosted","title":"Managed Providers (FlowStack-hosted)","text":"<pre><code>agent = Agent(\n    name=\"my-agent\",\n    api_key=\"fs_...\",\n    provider=\"bedrock\",  # Managed by FlowStack\n    model=\"claude-3-sonnet\"\n)\n</code></pre> <p>Benefits: No additional setup, optimized performance, included in session pricing.</p> <p>Available: AWS Bedrock (Claude, Llama, Mistral models)</p>"},{"location":"concepts/#byok-providers-bring-your-own-keys","title":"BYOK Providers (Bring Your Own Keys)","text":"<pre><code>agent = Agent(\n    name=\"my-agent\", \n    api_key=\"fs_...\",\n    provider=\"openai\",\n    model=\"gpt-4\",\n    byok={\"api_key\": \"sk-your-openai-key\"}  # Your own key\n)\n</code></pre> <p>Benefits: Direct billing from provider, no markup, full control.</p> <p>Supported: OpenAI, Anthropic, Cohere, Mistral, Ollama, AWS Bedrock</p>"},{"location":"concepts/#provider-switching","title":"Provider Switching","text":"<pre><code># Start with managed Bedrock\nagent = Agent(\"flexible-agent\", api_key=\"fs_...\", provider=\"bedrock\")\n\n# Switch to your own OpenAI account\nagent.set_provider(\"openai\", byok={\"api_key\": \"sk-...\"})\n\n# Or use Anthropic direct\nagent.set_provider(\"anthropic\", byok={\"api_key\": \"sk-ant-...\"})\n</code></pre>"},{"location":"concepts/#security-isolation","title":"Security &amp; Isolation","text":"<p>Every agent runs in its own secure environment:</p>"},{"location":"concepts/#agent-isolation","title":"Agent Isolation","text":"<ul> <li>Separate containers: Each agent runs in isolation</li> <li>Namespaced data: DataVault data is isolated per agent</li> <li>API key authentication: Only you can access your agents</li> <li>Rate limiting: Automatic protection against abuse</li> </ul>"},{"location":"concepts/#data-security","title":"Data Security","text":"<ul> <li>Encrypted at rest: All DataVault data is encrypted</li> <li>TLS in transit: All API calls use HTTPS</li> <li>No data sharing: Agents can't access each other's data</li> <li>Audit logs: We track access for compliance</li> </ul>"},{"location":"concepts/#best-practices","title":"Best Practices","text":"<p>Do</p> <ul> <li>Use strong API keys and keep them secret</li> <li>Validate inputs in your tools</li> <li>Store sensitive data in your own systems, not DataVault</li> <li>Use BYOK for sensitive AI processing</li> <li>Monitor usage and set up alerts</li> </ul> <p>Don't</p> <ul> <li>Hardcode API keys in your source code</li> <li>Store passwords or secrets in DataVault</li> <li>Allow unrestricted database access from tools</li> <li>Share API keys between environments</li> <li>Ignore usage alerts</li> </ul> <p>Ready to see these concepts in action? Check out our recipes for complete examples, or dive into the DataVault guide to learn about data persistence.</p>"},{"location":"datavault/","title":"DataVault - Zero-Config Persistence","text":"<p>Every FlowStack agent gets persistent storage with zero configuration. No database setup, no connection strings, no migrations. Just store and retrieve data.</p>"},{"location":"datavault/#what-is-datavault","title":"What is DataVault?","text":"<p>DataVault is MongoDB-backed storage that's automatically created for each agent. Think of it as a simple database that just works.</p> <pre><code># Store data\nagent.vault.store('users', {'name': 'Alice', 'age': 30})\n\n# Retrieve data  \nuser = agent.vault.retrieve('users', key='user_123')\n\n# Query data\nadults = agent.vault.query('users', {'age': {'$gte': 18}})\n</code></pre>"},{"location":"datavault/#core-operations","title":"Core Operations","text":""},{"location":"datavault/#store-data","title":"Store Data","text":"<p>Store any JSON-serializable data in named collections:</p> <pre><code># Store with auto-generated key\nkey = agent.vault.store('products', {\n    'name': 'Laptop',\n    'price': 999.99,\n    'category': 'electronics'\n})\nprint(key)  # \u2192 \"prod_abc123def456\"\n\n# Store with custom key\nagent.vault.store('products', {\n    'name': 'Mouse',\n    'price': 29.99,\n    'category': 'electronics'\n}, key='mouse-001')\n</code></pre>"},{"location":"datavault/#retrieve-data","title":"Retrieve Data","text":"<p>Get data back using keys or queries:</p> <pre><code># Get by key\nproduct = agent.vault.retrieve('products', key='mouse-001')\nprint(product['name'])  # \u2192 \"Mouse\"\n\n# Get all items in collection\nall_products = agent.vault.retrieve('products')\nprint(f\"Found {len(all_products)} products\")\n\n# Query with filters\nexpensive_items = agent.vault.query('products', {\n    'price': {'$gte': 500}\n})\n</code></pre>"},{"location":"datavault/#update-data","title":"Update Data","text":"<p>Modify existing items:</p> <pre><code># Update specific fields\nsuccess = agent.vault.update('products', 'mouse-001', {\n    'price': 24.99,\n    'sale': True\n})\n\n# Or retrieve, modify, and store back\nproduct = agent.vault.retrieve('products', key='mouse-001')\nproduct['price'] = 19.99\nagent.vault.store('products', product, key='mouse-001')\n</code></pre>"},{"location":"datavault/#delete-data","title":"Delete Data","text":"<p>Remove items you no longer need:</p> <pre><code># Delete specific item\nagent.vault.delete('products', key='mouse-001')\n\n# Clear entire collection (be careful!)\nagent.vault.clear('products')\n</code></pre>"},{"location":"datavault/#collections-as-namespaces","title":"Collections as Namespaces","text":"<p>Organize your data using collections - like database tables:</p> <pre><code># User data\nagent.vault.store('users', {\n    'id': 'user_123',\n    'name': 'Alice Johnson',\n    'email': 'alice@example.com',\n    'preferences': {\n        'theme': 'dark',\n        'notifications': True,\n        'language': 'en'\n    }\n})\n\n# Conversation history\nagent.vault.store('conversations', {\n    'user_id': 'user_123',\n    'messages': [\n        {'role': 'user', 'content': 'Hello!'},\n        {'role': 'assistant', 'content': 'Hi! How can I help?'}\n    ],\n    'started_at': '2024-01-15T10:00:00Z',\n    'last_activity': '2024-01-15T10:05:00Z'\n})\n\n# Application state\nagent.vault.store('app_state', {\n    'last_backup': '2024-01-15T00:00:00Z',\n    'feature_flags': {\n        'beta_features': True,\n        'advanced_mode': False\n    },\n    'metrics': {\n        'total_users': 1250,\n        'active_sessions': 45\n    }\n})\n</code></pre>"},{"location":"datavault/#query-patterns","title":"Query Patterns","text":"<p>DataVault supports MongoDB-style queries for complex data retrieval:</p>"},{"location":"datavault/#basic-queries","title":"Basic Queries","text":"<pre><code># Exact match\nusers_named_alice = agent.vault.query('users', {'name': 'Alice Johnson'})\n\n# Multiple conditions (AND)\nyoung_adults = agent.vault.query('users', {\n    'age': {'$gte': 18, '$lt': 30},\n    'active': True\n})\n\n# OR conditions\npower_users = agent.vault.query('users', {\n    '$or': [\n        {'premium': True},\n        {'login_count': {'$gte': 100}}\n    ]\n})\n</code></pre>"},{"location":"datavault/#advanced-queries","title":"Advanced Queries","text":"<pre><code># Text search\nsearch_results = agent.vault.query('products', {\n    'name': {'$regex': 'laptop', '$options': 'i'}  # Case-insensitive\n})\n\n# Array queries\nelectronics = agent.vault.query('products', {\n    'categories': {'$in': ['electronics', 'computers']}\n})\n\n# Nested field queries\ndark_theme_users = agent.vault.query('users', {\n    'preferences.theme': 'dark'\n})\n\n# Sorting and limiting\nrecent_conversations = agent.vault.query('conversations', \n    filter={'user_id': 'user_123'},\n    sort=[('last_activity', -1)],  # Descending\n    limit=10\n)\n</code></pre>"},{"location":"datavault/#aggregation","title":"Aggregation","text":"<p>Count and analyze your data:</p> <pre><code># Count items\ntotal_users = agent.vault.count('users')\nactive_users = agent.vault.count('users', {'active': True})\n\n# List all collections\ncollections = agent.vault.list_collections()\nprint(f\"Available collections: {collections}\")\n</code></pre>"},{"location":"datavault/#real-world-examples","title":"Real-World Examples","text":""},{"location":"datavault/#e-commerce-shopping-cart","title":"E-commerce Shopping Cart","text":"<pre><code>@agent.tool\ndef add_to_cart(user_id: str, product_id: str, quantity: int = 1):\n    \"\"\"Add item to user's shopping cart\"\"\"\n    # Get existing cart or create new one\n    cart = agent.vault.retrieve('carts', key=user_id) or {\n        'user_id': user_id,\n        'items': [],\n        'total': 0.0,\n        'created_at': datetime.now().isoformat()\n    }\n\n    # Get product details\n    product = agent.vault.retrieve('products', key=product_id)\n    if not product:\n        return {'error': 'Product not found'}\n\n    # Add or update item in cart\n    for item in cart['items']:\n        if item['product_id'] == product_id:\n            item['quantity'] += quantity\n            break\n    else:\n        cart['items'].append({\n            'product_id': product_id,\n            'name': product['name'],\n            'price': product['price'],\n            'quantity': quantity\n        })\n\n    # Recalculate total\n    cart['total'] = sum(item['price'] * item['quantity'] for item in cart['items'])\n    cart['updated_at'] = datetime.now().isoformat()\n\n    # Save cart\n    agent.vault.store('carts', cart, key=user_id)\n\n    return {\n        'message': f\"Added {quantity}x {product['name']} to cart\",\n        'cart_total': cart['total'],\n        'item_count': len(cart['items'])\n    }\n\n@agent.tool\ndef get_cart(user_id: str):\n    \"\"\"Get user's current shopping cart\"\"\"\n    cart = agent.vault.retrieve('carts', key=user_id)\n    if not cart:\n        return {'message': 'Cart is empty', 'items': [], 'total': 0}\n\n    return {\n        'items': cart['items'],\n        'total': cart['total'],\n        'item_count': len(cart['items'])\n    }\n</code></pre>"},{"location":"datavault/#fitness-tracking","title":"Fitness Tracking","text":"<pre><code>@agent.tool\ndef log_workout(user_id: str, workout_type: str, duration: int, calories: int):\n    \"\"\"Log a workout session\"\"\"\n    workout = {\n        'user_id': user_id,\n        'type': workout_type,\n        'duration_minutes': duration,\n        'calories_burned': calories,\n        'date': datetime.now().date().isoformat(),\n        'timestamp': datetime.now().isoformat()\n    }\n\n    # Store workout\n    workout_key = agent.vault.store('workouts', workout)\n\n    # Update user stats\n    stats = agent.vault.retrieve('fitness_stats', key=user_id) or {\n        'user_id': user_id,\n        'total_workouts': 0,\n        'total_duration': 0,\n        'total_calories': 0,\n        'favorite_activities': {},\n        'streak_days': 0\n    }\n\n    stats['total_workouts'] += 1\n    stats['total_duration'] += duration\n    stats['total_calories'] += calories\n\n    # Track favorite activities\n    if workout_type not in stats['favorite_activities']:\n        stats['favorite_activities'][workout_type] = 0\n    stats['favorite_activities'][workout_type] += 1\n\n    # Calculate streak (simplified)\n    today = datetime.now().date()\n    recent_workouts = agent.vault.query('workouts', {\n        'user_id': user_id,\n        'date': today.isoformat()\n    })\n\n    if len(recent_workouts) == 1:  # First workout today\n        yesterday_workouts = agent.vault.query('workouts', {\n            'user_id': user_id,\n            'date': (today - timedelta(days=1)).isoformat()\n        })\n        if yesterday_workouts:\n            stats['streak_days'] += 1\n        else:\n            stats['streak_days'] = 1\n\n    agent.vault.store('fitness_stats', stats, key=user_id)\n\n    return {\n        'message': f'Logged {duration} min {workout_type} workout',\n        'workout_id': workout_key,\n        'total_workouts': stats['total_workouts'],\n        'streak_days': stats['streak_days']\n    }\n\n@agent.tool\ndef get_fitness_summary(user_id: str, days: int = 7):\n    \"\"\"Get fitness summary for recent days\"\"\"\n    start_date = (datetime.now().date() - timedelta(days=days)).isoformat()\n\n    recent_workouts = agent.vault.query('workouts', {\n        'user_id': user_id,\n        'date': {'$gte': start_date}\n    })\n\n    stats = agent.vault.retrieve('fitness_stats', key=user_id) or {}\n\n    summary = {\n        'period_days': days,\n        'workouts_this_period': len(recent_workouts),\n        'total_duration': sum(w['duration_minutes'] for w in recent_workouts),\n        'total_calories': sum(w['calories_burned'] for w in recent_workouts),\n        'workout_types': list(set(w['type'] for w in recent_workouts)),\n        'overall_stats': stats\n    }\n\n    return summary\n</code></pre>"},{"location":"datavault/#customer-support-memory","title":"Customer Support Memory","text":"<pre><code>@agent.tool\ndef remember_customer_context(customer_id: str, context: str, category: str = \"general\"):\n    \"\"\"Remember important context about a customer\"\"\"\n    memory = {\n        'customer_id': customer_id,\n        'context': context,\n        'category': category,\n        'timestamp': datetime.now().isoformat(),\n        'agent_session': 'current'  # Track which conversation this came from\n    }\n\n    memory_key = agent.vault.store('customer_memory', memory)\n\n    return {\n        'message': f'Remembered: {context}',\n        'memory_id': memory_key,\n        'category': category\n    }\n\n@agent.tool\ndef recall_customer_context(customer_id: str, category: str = None):\n    \"\"\"Recall previous context about a customer\"\"\"\n    query = {'customer_id': customer_id}\n    if category:\n        query['category'] = category\n\n    memories = agent.vault.query('customer_memory', \n        filter=query,\n        sort=[('timestamp', -1)],\n        limit=10\n    )\n\n    if not memories:\n        return {'message': 'No previous context found for this customer'}\n\n    context_summary = []\n    for memory in memories:\n        context_summary.append({\n            'context': memory['context'],\n            'category': memory['category'],\n            'when': memory['timestamp']\n        })\n\n    return {\n        'customer_id': customer_id,\n        'context_items': len(memories),\n        'contexts': context_summary\n    }\n\n@agent.tool\ndef search_customer_history(query: str):\n    \"\"\"Search across all customer interactions\"\"\"\n    # Text search across customer memory\n    results = agent.vault.query('customer_memory', {\n        '$or': [\n            {'context': {'$regex': query, '$options': 'i'}},\n            {'category': {'$regex': query, '$options': 'i'}}\n        ]\n    })\n\n    return {\n        'query': query,\n        'matches': len(results),\n        'results': results[:5]  # Limit to top 5 matches\n    }\n</code></pre>"},{"location":"datavault/#performance-tips","title":"Performance Tips","text":""},{"location":"datavault/#efficient-queries","title":"Efficient Queries","text":"<pre><code># \u2705 Good: Use indexes (key-based lookups are fastest)\nuser = agent.vault.retrieve('users', key='user_123')\n\n# \u2705 Good: Query with specific fields\nrecent_orders = agent.vault.query('orders', {\n    'user_id': 'user_123',\n    'status': 'completed',\n    'created_at': {'$gte': '2024-01-01'}\n})\n\n# \u26a0\ufe0f Slower: Querying without indexes\nall_users = agent.vault.retrieve('users')  # Gets everything\nexpensive_search = agent.vault.query('products', {\n    'description': {'$regex': 'bluetooth'}  # Text search across all descriptions\n})\n</code></pre>"},{"location":"datavault/#data-organization","title":"Data Organization","text":"<pre><code># \u2705 Good: Organize related data together\nuser_profile = {\n    'basic_info': {'name': 'Alice', 'email': 'alice@example.com'},\n    'preferences': {'theme': 'dark', 'language': 'en'},\n    'metadata': {'created_at': '2024-01-01', 'last_login': '2024-01-15'}\n}\n\n# \u2705 Good: Use consistent key patterns\nagent.vault.store('users', user_profile, key='user_123')\nagent.vault.store('user_sessions', session_data, key='user_123_session_456')\n\n# \u26a0\ufe0f Less efficient: Storing everything separately\nagent.vault.store('user_names', {'name': 'Alice'}, key='user_123')\nagent.vault.store('user_emails', {'email': 'alice@example.com'}, key='user_123')\nagent.vault.store('user_themes', {'theme': 'dark'}, key='user_123')\n</code></pre>"},{"location":"datavault/#cleanup-and-maintenance","title":"Cleanup and Maintenance","text":"<pre><code>@agent.tool\ndef cleanup_old_data():\n    \"\"\"Clean up old data to save space\"\"\"\n    from datetime import datetime, timedelta\n\n    # Delete old conversation logs (older than 30 days)\n    cutoff_date = (datetime.now() - timedelta(days=30)).isoformat()\n\n    old_conversations = agent.vault.query('conversations', {\n        'last_activity': {'$lt': cutoff_date}\n    })\n\n    deleted_count = 0\n    for conv in old_conversations:\n        agent.vault.delete('conversations', key=conv['_id'])\n        deleted_count += 1\n\n    return f\"Cleaned up {deleted_count} old conversations\"\n\n@agent.tool\ndef get_storage_stats():\n    \"\"\"Get storage usage statistics\"\"\"\n    collections = agent.vault.list_collections()\n    stats = {}\n\n    for collection in collections:\n        count = agent.vault.count(collection)\n        stats[collection] = count\n\n    return {\n        'collections': len(collections),\n        'total_items': sum(stats.values()),\n        'breakdown': stats\n    }\n</code></pre>"},{"location":"datavault/#best-practices","title":"Best Practices","text":""},{"location":"datavault/#do","title":"\u2705 Do","text":"<ul> <li>Use descriptive collection names: <code>user_preferences</code> not <code>prefs</code></li> <li>Include timestamps: Always add <code>created_at</code> and <code>updated_at</code> fields</li> <li>Use consistent key patterns: <code>user_123</code>, <code>session_user_123_456</code></li> <li>Store related data together: Don't create unnecessary collections</li> <li>Clean up old data: Implement periodic cleanup to manage storage</li> </ul>"},{"location":"datavault/#dont","title":"\u274c Don't","text":"<ul> <li>Store large files: DataVault is for structured data, not media</li> <li>Store secrets: Use BYOK for API keys, not DataVault</li> <li>Create too many collections: Keep it organized but not over-fragmented</li> <li>Ignore query performance: Use specific queries, not broad searches</li> <li>Store temporary data permanently: Clean up session data and caches</li> </ul>"},{"location":"datavault/#security-considerations","title":"Security Considerations","text":"<ul> <li>DataVault data is isolated per agent - other agents can't access it</li> <li>Data is encrypted at rest using industry-standard encryption</li> <li>No cross-agent data sharing - each agent has its own namespace</li> <li>Use for application data only - not for user passwords or API keys</li> </ul> <p>Ready to build something with persistent data? Check out our recipes for complete examples, or learn about deployment to get your agent live!</p>"},{"location":"deployment/","title":"Deployment Guide","text":"<p>Turn your local agent into a production API with one command. FlowStack handles all the infrastructure complexity for you.</p>"},{"location":"deployment/#quick-deployment","title":"Quick Deployment","text":"<pre><code>from flowstack import Agent\n\n# Build your agent\nagent = Agent(\"my-agent\", api_key=\"fs_...\")\n\n@agent.tool\ndef my_function():\n    \"\"\"My custom tool\"\"\"\n    return {\"result\": \"success\"}\n\n# Deploy to production\nendpoint = agent.deploy()\nprint(f\"Live at: {endpoint}\")\n# \u2192 https://api.flowstack.fun/agents/my-agent\n</code></pre> <p>That's it! Your agent is now running in production.</p>"},{"location":"deployment/#what-happens-during-deployment","title":"What Happens During Deployment","text":"<p>When you call <code>agent.deploy()</code>, FlowStack automatically:</p>"},{"location":"deployment/#1-code-packaging","title":"1. Code Packaging \u26a1","text":"<ul> <li>Packages your agent code, tools, and configuration</li> <li>Handles dependencies and imports</li> <li>Creates deployment artifacts</li> </ul>"},{"location":"deployment/#2-infrastructure-provisioning","title":"2. Infrastructure Provisioning \ud83c\udfd7\ufe0f","text":"<ul> <li>Spins up Lambda functions with your agent code</li> <li>Configures API Gateway for HTTP access</li> <li>Sets up load balancing and auto-scaling</li> <li>Creates monitoring and logging</li> </ul>"},{"location":"deployment/#3-data-setup","title":"3. Data Setup \ud83d\udcbe","text":"<ul> <li>Provisions your DataVault namespace</li> <li>Sets up database connections and permissions</li> <li>Configures data isolation and security</li> </ul>"},{"location":"deployment/#4-security-configuration","title":"4. Security Configuration \ud83d\udd12","text":"<ul> <li>Applies API key authentication</li> <li>Sets up rate limiting and abuse protection</li> <li>Configures HTTPS and network security</li> <li>Implements request isolation</li> </ul>"},{"location":"deployment/#5-health-checks","title":"5. Health Checks \u2705","text":"<ul> <li>Verifies your agent starts correctly</li> <li>Tests tool functionality</li> <li>Validates API responses</li> <li>Confirms monitoring is working</li> </ul>"},{"location":"deployment/#6-endpoint-creation","title":"6. Endpoint Creation \ud83c\udf10","text":"<ul> <li>Assigns your unique API endpoint</li> <li>Configures routing and load balancing</li> <li>Sets up global edge caching</li> <li>Makes your agent accessible worldwide</li> </ul>"},{"location":"deployment/#deployment-environments","title":"Deployment Environments","text":""},{"location":"deployment/#development-environment","title":"Development Environment","text":"<p>Perfect for testing and iteration:</p> <pre><code># Deploy to dev environment\ndev_endpoint = agent.deploy(environment=\"dev\")\n# \u2192 https://api.flowstack.fun/agents/my-agent-dev\n</code></pre> <p>Development Features: - \u2705 Faster deployment (30-60 seconds) - \u2705 More verbose logging and debugging - \u2705 Higher error tolerance - \u2705 Separate DataVault namespace - \u2705 Cost-optimized for testing</p>"},{"location":"deployment/#production-environment","title":"Production Environment","text":"<p>Optimized for real users:</p> <pre><code># Deploy to production\nprod_endpoint = agent.deploy(environment=\"prod\")\n# \u2192 https://api.flowstack.fun/agents/my-agent\n</code></pre> <p>Production Features: - \u2705 Enhanced performance and reliability - \u2705 Advanced monitoring and alerting - \u2705 Automatic scaling and load balancing - \u2705 Production SLA guarantees - \u2705 Enhanced security and isolation</p>"},{"location":"deployment/#what-you-get","title":"What You Get","text":""},{"location":"deployment/#instant-api-endpoint","title":"Instant API Endpoint","text":"<p>Your agent becomes accessible via HTTPS API:</p> <pre><code># Chat with your agent\ncurl -X POST https://api.flowstack.fun/agents/my-agent/chat \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: fs_your_api_key\" \\\n  -d '{\"message\": \"Hello!\"}'\n</code></pre>"},{"location":"deployment/#automatic-scaling","title":"Automatic Scaling","text":"<p>FlowStack handles traffic from 0 to thousands of requests:</p> <ul> <li>Cold Start Optimization: Minimized startup time</li> <li>Auto-Scaling: Scales up/down based on demand</li> <li>Load Balancing: Distributes requests efficiently</li> <li>Global Edge: Served from locations worldwide</li> </ul>"},{"location":"deployment/#built-in-monitoring","title":"Built-in Monitoring","text":"<p>Track your agent's performance in real-time:</p> <pre><code># Get deployment health\nhealth = agent.get_deployment_health()\nprint(f\"Status: {health['status']}\")\nprint(f\"Uptime: {health['uptime_percentage']}%\")\nprint(f\"Response time: {health['avg_response_time_ms']}ms\")\n</code></pre>"},{"location":"deployment/#datavault-integration","title":"DataVault Integration","text":"<p>Your persistent storage is automatically configured:</p> <pre><code># Works immediately after deployment\n@agent.tool\ndef store_user_data(user_id: str, data: dict):\n    \"\"\"Store user data in DataVault\"\"\"\n    agent.vault.store('users', data, key=user_id)\n    return {\"stored\": True}\n</code></pre>"},{"location":"deployment/#deployment-options","title":"Deployment Options","text":""},{"location":"deployment/#basic-deployment","title":"Basic Deployment","text":"<pre><code># Simplest deployment\nendpoint = agent.deploy()\n</code></pre>"},{"location":"deployment/#advanced-deployment","title":"Advanced Deployment","text":"<pre><code># Deployment with configuration\nendpoint = agent.deploy(\n    environment=\"prod\",           # prod or dev\n    region=\"us-east-1\",          # AWS region\n    timeout=30,                  # Function timeout in seconds\n    memory=512,                  # Memory allocation in MB\n    description=\"My production agent\",\n    tags={\"team\": \"ai\", \"project\": \"customer-service\"}\n)\n</code></pre>"},{"location":"deployment/#deployment-with-custom-domain","title":"Deployment with Custom Domain","text":"<pre><code># Deploy with custom domain (enterprise feature)\nendpoint = agent.deploy(\n    environment=\"prod\",\n    custom_domain=\"my-agent.mycompany.com\"\n)\n</code></pre>"},{"location":"deployment/#api-endpoints","title":"API Endpoints","text":"<p>After deployment, your agent provides several endpoints:</p>"},{"location":"deployment/#chat-endpoint","title":"Chat Endpoint","text":"<p>POST <code>/agents/{agent-name}/chat</code></p> <p>Send messages to your agent:</p> <pre><code>curl -X POST https://api.flowstack.fun/agents/my-agent/chat \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: fs_your_api_key\" \\\n  -d '{\n    \"message\": \"What can you help me with?\",\n    \"context\": {\"user_id\": \"user123\"},\n    \"temperature\": 0.7\n  }'\n</code></pre> <p>Response: <pre><code>{\n  \"message\": \"I can help you with...\",\n  \"agent\": \"my-agent\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\",\n  \"session_id\": \"sess_abc123\"\n}\n</code></pre></p>"},{"location":"deployment/#invoke-endpoint","title":"Invoke Endpoint","text":"<p>POST <code>/agents/{agent-name}/invoke</code></p> <p>Advanced interface with full message control:</p> <pre><code>curl -X POST https://api.flowstack.fun/agents/my-agent/invoke \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: fs_your_api_key\" \\\n  -d '{\n    \"messages\": [\n      {\"role\": \"user\", \"content\": \"Hello\"},\n      {\"role\": \"assistant\", \"content\": \"Hi! How can I help?\"},\n      {\"role\": \"user\", \"content\": \"What time is it?\"}\n    ],\n    \"temperature\": 0.8,\n    \"max_tokens\": 150\n  }'\n</code></pre>"},{"location":"deployment/#health-endpoint","title":"Health Endpoint","text":"<p>GET <code>/agents/{agent-name}/health</code></p> <p>Check agent health and status:</p> <pre><code>curl https://api.flowstack.fun/agents/my-agent/health \\\n  -H \"X-API-Key: fs_your_api_key\"\n</code></pre> <p>Response: <pre><code>{\n  \"status\": \"healthy\",\n  \"uptime\": \"99.9%\",\n  \"avg_response_time_ms\": 245,\n  \"last_deployed\": \"2024-01-15T08:00:00Z\",\n  \"version\": \"1.2.0\"\n}\n</code></pre></p>"},{"location":"deployment/#usage-endpoint","title":"Usage Endpoint","text":"<p>GET <code>/agents/{agent-name}/usage</code></p> <p>Get usage statistics:</p> <pre><code>curl https://api.flowstack.fun/agents/my-agent/usage \\\n  -H \"X-API-Key: fs_your_api_key\"\n</code></pre>"},{"location":"deployment/#managing-deployments","title":"Managing Deployments","text":""},{"location":"deployment/#update-deployment","title":"Update Deployment","text":"<p>Deploy changes to your existing agent:</p> <pre><code># Update with new code\nagent.deploy()  # Updates existing deployment\n\n# Force new deployment\nagent.deploy(force_update=True)\n</code></pre>"},{"location":"deployment/#rollback-deployment","title":"Rollback Deployment","text":"<p>Revert to a previous version:</p> <pre><code># Rollback to previous version\nagent.rollback()\n\n# Rollback to specific version\nagent.rollback(version=\"1.1.0\")\n</code></pre>"},{"location":"deployment/#delete-deployment","title":"Delete Deployment","text":"<p>Remove your agent from production:</p> <pre><code># Delete deployment (keeps data)\nagent.undeploy()\n\n# Delete everything including data\nagent.undeploy(delete_data=True)\n</code></pre>"},{"location":"deployment/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"deployment/#environment-variables","title":"Environment Variables","text":"<p>Use environment variables for configuration:</p> <pre><code>import os\n\nagent = Agent(\n    name=\"my-agent\",\n    api_key=os.getenv(\"FLOWSTACK_API_KEY\"),\n    provider=os.getenv(\"AI_PROVIDER\", \"bedrock\"),\n    model=os.getenv(\"AI_MODEL\", \"claude-3-sonnet\")\n)\n</code></pre>"},{"location":"deployment/#error-handling","title":"Error Handling","text":"<p>Implement robust error handling for production:</p> <pre><code>@agent.tool\ndef robust_function(data: str) -&gt; dict:\n    \"\"\"Example of robust error handling\"\"\"\n    try:\n        # Your logic here\n        result = process_data(data)\n        return {\"success\": True, \"result\": result}\n\n    except ValueError as e:\n        return {\"success\": False, \"error\": \"Invalid data format\", \"details\": str(e)}\n\n    except Exception as e:\n        # Log error for debugging\n        print(f\"Unexpected error: {e}\")\n        return {\"success\": False, \"error\": \"Internal error\", \"retry\": True}\n</code></pre>"},{"location":"deployment/#input-validation","title":"Input Validation","text":"<p>Validate inputs in your tools:</p> <pre><code>@agent.tool\ndef validate_inputs(email: str, age: int) -&gt; dict:\n    \"\"\"Example of input validation\"\"\"\n\n    # Validate email format\n    if \"@\" not in email or \".\" not in email:\n        return {\"error\": \"Invalid email format\"}\n\n    # Validate age range\n    if not 0 &lt;= age &lt;= 150:\n        return {\"error\": \"Age must be between 0 and 150\"}\n\n    # Process valid inputs\n    return {\"email\": email, \"age\": age, \"valid\": True}\n</code></pre>"},{"location":"deployment/#resource-management","title":"Resource Management","text":"<p>Use DataVault efficiently:</p> <pre><code>@agent.tool\ndef efficient_data_handling(user_id: str) -&gt; dict:\n    \"\"\"Example of efficient data handling\"\"\"\n\n    # Check if data exists before creating\n    existing_data = agent.vault.retrieve('users', key=user_id)\n\n    if existing_data:\n        # Update existing data\n        agent.vault.update('users', user_id, {\n            'last_seen': datetime.now().isoformat()\n        })\n        return {\"action\": \"updated\", \"user_id\": user_id}\n    else:\n        # Create new data\n        agent.vault.store('users', {\n            'user_id': user_id,\n            'created_at': datetime.now().isoformat(),\n            'last_seen': datetime.now().isoformat()\n        }, key=user_id)\n        return {\"action\": \"created\", \"user_id\": user_id}\n</code></pre>"},{"location":"deployment/#performance-optimization","title":"Performance Optimization","text":""},{"location":"deployment/#response-time","title":"Response Time","text":"<p>Optimize for faster responses:</p> <pre><code># Use faster models for simple tasks\nif task_complexity == \"simple\":\n    agent.set_model(\"claude-3-haiku\")  # Faster model\nelse:\n    agent.set_model(\"claude-3-sonnet\")  # More capable model\n</code></pre>"},{"location":"deployment/#memory-usage","title":"Memory Usage","text":"<p>Efficient memory management:</p> <pre><code>@agent.tool\ndef memory_efficient_processing(large_data: list) -&gt; dict:\n    \"\"\"Process large data efficiently\"\"\"\n\n    # Process in chunks instead of all at once\n    chunk_size = 100\n    results = []\n\n    for i in range(0, len(large_data), chunk_size):\n        chunk = large_data[i:i + chunk_size]\n        chunk_result = process_chunk(chunk)\n        results.append(chunk_result)\n\n    return {\"processed_chunks\": len(results), \"total_items\": len(large_data)}\n</code></pre>"},{"location":"deployment/#caching","title":"Caching","text":"<p>Use DataVault for caching:</p> <pre><code>@agent.tool\ndef cached_expensive_operation(query: str) -&gt; dict:\n    \"\"\"Cache expensive operations\"\"\"\n\n    # Check cache first\n    cache_key = f\"cache_{hash(query)}\"\n    cached_result = agent.vault.retrieve('cache', key=cache_key)\n\n    if cached_result:\n        return {\"result\": cached_result, \"from_cache\": True}\n\n    # Perform expensive operation\n    result = expensive_operation(query)\n\n    # Cache result with expiration\n    agent.vault.store('cache', {\n        'result': result,\n        'expires_at': (datetime.now() + timedelta(hours=1)).isoformat()\n    }, key=cache_key)\n\n    return {\"result\": result, \"from_cache\": False}\n</code></pre>"},{"location":"deployment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/#common-deployment-issues","title":"Common Deployment Issues","text":""},{"location":"deployment/#1-import-errors","title":"1. Import Errors","text":"<p>Problem: Module not found errors after deployment</p> <p>Solution: Ensure all dependencies are importable</p> <pre><code># Test imports before deployment\ntry:\n    import requests\n    import pandas as pd\n    from my_custom_module import my_function\n    print(\"\u2705 All imports successful\")\nexcept ImportError as e:\n    print(f\"\u274c Import error: {e}\")\n</code></pre>"},{"location":"deployment/#2-tool-function-errors","title":"2. Tool Function Errors","text":"<p>Problem: Tools fail during deployment</p> <p>Solution: Test tools locally first</p> <pre><code># Test your tools before deployment\n@agent.tool\ndef test_tool() -&gt; dict:\n    \"\"\"Test tool functionality\"\"\"\n    return {\"status\": \"working\"}\n\n# Test locally\nresult = test_tool()\nprint(f\"Tool test result: {result}\")\n</code></pre>"},{"location":"deployment/#3-timeout-issues","title":"3. Timeout Issues","text":"<p>Problem: Deployment times out</p> <p>Solution: Optimize code and increase timeout</p> <pre><code># Deploy with longer timeout\nendpoint = agent.deploy(timeout=60)  # 60 seconds\n</code></pre>"},{"location":"deployment/#4-memory-issues","title":"4. Memory Issues","text":"<p>Problem: Out of memory errors</p> <p>Solution: Increase memory allocation</p> <pre><code># Deploy with more memory\nendpoint = agent.deploy(memory=1024)  # 1GB memory\n</code></pre>"},{"location":"deployment/#debugging-production-issues","title":"Debugging Production Issues","text":""},{"location":"deployment/#1-check-logs","title":"1. Check Logs","text":"<pre><code># Get deployment logs\nlogs = agent.get_logs(lines=100)\nfor log in logs:\n    print(f\"{log['timestamp']}: {log['message']}\")\n</code></pre>"},{"location":"deployment/#2-monitor-health","title":"2. Monitor Health","text":"<pre><code># Check agent health\nhealth = agent.get_deployment_health()\nif health['status'] != 'healthy':\n    print(f\"\u26a0\ufe0f Agent unhealthy: {health}\")\n</code></pre>"},{"location":"deployment/#3-test-endpoint","title":"3. Test Endpoint","text":"<pre><code># Test your deployed agent\ntry:\n    response = agent.chat(\"Health check\")\n    print(f\"\u2705 Agent responding: {response}\")\nexcept Exception as e:\n    print(f\"\u274c Agent not responding: {e}\")\n</code></pre> <p>Ready to deploy your agent? Start with the quickstart guide or check out our recipes for complete examples!</p>"},{"location":"production/","title":"Production Guide","text":"<p>Everything you need to know about running FlowStack agents in production environments.</p>"},{"location":"production/#production-architecture","title":"Production Architecture","text":"<p>When you deploy an agent, FlowStack creates a robust, scalable architecture:</p> <pre><code>graph TB\n    User[Users] --&gt; CDN[Global CDN]\n    CDN --&gt; Gateway[API Gateway]\n    Gateway --&gt; LB[Load Balancer]\n    LB --&gt; Lambda1[Lambda Instance 1]\n    LB --&gt; Lambda2[Lambda Instance 2] \n    LB --&gt; Lambda3[Lambda Instance N]\n    Lambda1 --&gt; DataVault[(DataVault)]\n    Lambda2 --&gt; DataVault\n    Lambda3 --&gt; DataVault\n    Lambda1 --&gt; AI[AI Providers]\n    Lambda2 --&gt; AI\n    Lambda3 --&gt; AI</code></pre>"},{"location":"production/#whats-included-in-production","title":"What's Included in Production","text":""},{"location":"production/#automatic-scaling","title":"Automatic Scaling","text":"<p>Your agent handles traffic spikes without configuration:</p> <ul> <li>0 to 1000+ concurrent requests - Automatic scaling</li> <li>Global distribution - Served from multiple regions</li> <li>Load balancing - Intelligent request routing</li> <li>Cold start optimization - Minimal startup latency</li> </ul>"},{"location":"production/#enterprise-grade-security","title":"Enterprise-Grade Security","text":"<p>Production deployments include comprehensive security:</p> <ul> <li>API key authentication - Secure access control</li> <li>Request isolation - Each request runs independently</li> <li>Rate limiting - Automatic abuse protection</li> <li>HTTPS encryption - All traffic encrypted</li> <li>Network isolation - Secure runtime environment</li> </ul>"},{"location":"production/#built-in-monitoring","title":"Built-in Monitoring","text":"<p>Comprehensive observability out of the box:</p> <ul> <li>Real-time metrics - Response times, error rates, throughput</li> <li>Error tracking - Automatic error capture and alerting</li> <li>Usage analytics - Session tracking and billing metrics</li> <li>Health monitoring - Automatic health checks and recovery</li> </ul>"},{"location":"production/#data-persistence","title":"Data Persistence","text":"<p>DataVault provides enterprise-grade data storage:</p> <ul> <li>MongoDB-backed - Reliable, scalable database</li> <li>Automatic backups - Data protection and recovery</li> <li>Encryption at rest - Secure data storage</li> <li>Namespaced isolation - Your data stays separate</li> </ul>"},{"location":"production/#production-checklist","title":"Production Checklist","text":"<p>Before going live, ensure your agent is production-ready:</p>"},{"location":"production/#code-quality","title":"\u2705 Code Quality","text":"<ul> <li> Error handling - All tools handle errors gracefully</li> <li> Input validation - Validate all user inputs</li> <li> Type hints - Use proper type annotations</li> <li> Docstrings - Document all tools and functions</li> <li> Testing - Test tools thoroughly before deployment</li> </ul>"},{"location":"production/#performance","title":"\u2705 Performance","text":"<ul> <li> Response time - Tools complete within reasonable time</li> <li> Memory usage - Efficient memory management</li> <li> Caching - Cache expensive operations</li> <li> Model selection - Use appropriate models for tasks</li> <li> Timeout handling - Handle slow operations gracefully</li> </ul>"},{"location":"production/#security","title":"\u2705 Security","text":"<ul> <li> API key protection - Never expose API keys in code</li> <li> Input sanitization - Clean user inputs</li> <li> Data validation - Validate all data before processing</li> <li> Error messages - Don't expose sensitive information</li> <li> Access control - Implement proper authorization</li> </ul>"},{"location":"production/#monitoring","title":"\u2705 Monitoring","text":"<ul> <li> Health checks - Verify agent responds correctly</li> <li> Usage tracking - Monitor session consumption</li> <li> Error monitoring - Track and handle errors</li> <li> Performance monitoring - Watch response times</li> <li> Alerting setup - Get notified of issues</li> </ul>"},{"location":"production/#performance-optimization","title":"Performance Optimization","text":""},{"location":"production/#response-time-optimization","title":"Response Time Optimization","text":"<pre><code>from flowstack import Agent, Models\n\nagent = Agent(\"optimized-agent\", api_key=\"fs_...\")\n\n@agent.tool\ndef fast_operation(query: str) -&gt; dict:\n    \"\"\"Optimized for speed\"\"\"\n\n    # Check cache first\n    cache_key = f\"fast_{hash(query)}\"\n    cached = agent.vault.retrieve('cache', key=cache_key)\n\n    if cached and not is_expired(cached):\n        return {\"result\": cached['data'], \"cached\": True}\n\n    # Use fastest model for simple queries\n    if is_simple_query(query):\n        agent.set_model(Models.CLAUDE_35_HAIKU)  # Fastest Claude model\n\n    # Process and cache result\n    result = process_query(query)\n    agent.vault.store('cache', {\n        'data': result,\n        'expires_at': get_expiry_time()\n    }, key=cache_key)\n\n    return {\"result\": result, \"cached\": False}\n\ndef is_simple_query(query: str) -&gt; bool:\n    \"\"\"Determine if query is simple enough for fast model\"\"\"\n    simple_keywords = ['hello', 'help', 'what', 'how', 'basic']\n    return any(keyword in query.lower() for keyword in simple_keywords)\n</code></pre>"},{"location":"production/#memory-optimization","title":"Memory Optimization","text":"<pre><code>@agent.tool\ndef memory_efficient_processing(data: list) -&gt; dict:\n    \"\"\"Process large datasets efficiently\"\"\"\n\n    # Process in chunks to avoid memory issues\n    chunk_size = 100\n    processed_count = 0\n\n    for i in range(0, len(data), chunk_size):\n        chunk = data[i:i + chunk_size]\n\n        # Process chunk\n        process_data_chunk(chunk)\n        processed_count += len(chunk)\n\n        # Optional: Store intermediate results\n        if processed_count % 1000 == 0:\n            save_checkpoint(processed_count)\n\n    return {\"processed\": processed_count, \"total\": len(data)}\n</code></pre>"},{"location":"production/#provider-optimization","title":"Provider Optimization","text":"<pre><code>@agent.tool\ndef cost_optimized_request(task: str, complexity: str = \"medium\") -&gt; dict:\n    \"\"\"Route to optimal provider based on task complexity\"\"\"\n\n    if complexity == \"simple\":\n        # Use cheapest option for simple tasks\n        agent.set_provider(\"openai\", byok={\"api_key\": \"sk-...\"})\n        agent.set_model(\"gpt-3.5-turbo\")\n    elif complexity == \"complex\":\n        # Use most capable model for complex tasks\n        agent.set_provider(\"anthropic\", byok={\"api_key\": \"sk-ant-...\"})\n        agent.set_model(\"claude-3-opus-20240229\")\n    else:\n        # Use balanced option for medium complexity\n        agent.set_provider(\"bedrock\")  # Managed\n        agent.set_model(Models.CLAUDE_35_SONNET)\n\n    response = agent.chat(task)\n    return {\"response\": response, \"provider\": agent.provider, \"model\": agent.model}\n</code></pre>"},{"location":"production/#error-handling-recovery","title":"Error Handling &amp; Recovery","text":""},{"location":"production/#robust-error-handling","title":"Robust Error Handling","text":"<pre><code>from flowstack import Agent, FlowStackError, QuotaExceededError\nimport logging\n\n# Configure logging for production\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nagent = Agent(\"production-agent\", api_key=\"fs_...\")\n\n@agent.tool\ndef production_ready_tool(data: dict) -&gt; dict:\n    \"\"\"Production-ready tool with comprehensive error handling\"\"\"\n\n    try:\n        # Validate inputs\n        if not data or not isinstance(data, dict):\n            return {\"error\": \"Invalid input: data must be a non-empty dictionary\"}\n\n        required_fields = ['id', 'type']\n        missing_fields = [field for field in required_fields if field not in data]\n        if missing_fields:\n            return {\"error\": f\"Missing required fields: {missing_fields}\"}\n\n        # Process data\n        result = process_business_logic(data)\n\n        # Log success\n        logger.info(f\"Successfully processed data for ID: {data['id']}\")\n\n        return {\"success\": True, \"result\": result, \"id\": data['id']}\n\n    except ValueError as e:\n        logger.warning(f\"Invalid data format: {e}\")\n        return {\"error\": \"Invalid data format\", \"details\": str(e), \"retry\": False}\n\n    except ConnectionError as e:\n        logger.error(f\"External service unavailable: {e}\")\n        return {\"error\": \"Service temporarily unavailable\", \"retry\": True}\n\n    except QuotaExceededError as e:\n        logger.warning(f\"Quota exceeded: {e}\")\n        return {\"error\": \"Usage limit reached\", \"upgrade_required\": True}\n\n    except FlowStackError as e:\n        logger.error(f\"FlowStack error: {e}\")\n        return {\"error\": \"Service error\", \"retry\": True}\n\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\", exc_info=True)\n        return {\"error\": \"Internal error\", \"retry\": True}\n\ndef process_business_logic(data: dict) -&gt; dict:\n    \"\"\"Your business logic here\"\"\"\n    # Simulate processing\n    return {\"processed\": True, \"timestamp\": \"2024-01-15T10:30:00Z\"}\n</code></pre>"},{"location":"production/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>@agent.tool\ndef resilient_operation(query: str) -&gt; dict:\n    \"\"\"Operation that gracefully degrades on failures\"\"\"\n\n    try:\n        # Try primary approach\n        result = primary_processing_method(query)\n        return {\"result\": result, \"method\": \"primary\", \"quality\": \"high\"}\n\n    except Exception as e:\n        logger.warning(f\"Primary method failed: {e}\")\n\n        try:\n            # Fallback to secondary approach\n            result = secondary_processing_method(query)\n            return {\"result\": result, \"method\": \"secondary\", \"quality\": \"medium\"}\n\n        except Exception as e:\n            logger.error(f\"Secondary method failed: {e}\")\n\n            # Final fallback - basic response\n            return {\n                \"result\": \"I'm experiencing technical difficulties. Please try again later.\",\n                \"method\": \"fallback\",\n                \"quality\": \"low\",\n                \"error\": True\n            }\n</code></pre>"},{"location":"production/#monitoring-alerting","title":"Monitoring &amp; Alerting","text":""},{"location":"production/#usage-monitoring","title":"Usage Monitoring","text":"<pre><code>@agent.tool\ndef monitor_usage() -&gt; dict:\n    \"\"\"Monitor and alert on usage patterns\"\"\"\n\n    usage = agent.get_usage()\n\n    # Check for approaching limits\n    if usage.usage_percentage &gt; 90:\n        send_alert(\"critical\", f\"Usage at {usage.usage_percentage}% - immediate action required\")\n    elif usage.usage_percentage &gt; 80:\n        send_alert(\"warning\", f\"Usage at {usage.usage_percentage}% - consider upgrading\")\n\n    # Track usage patterns\n    agent.vault.store('usage_logs', {\n        'timestamp': datetime.now().isoformat(),\n        'sessions_used': usage.sessions_used,\n        'sessions_limit': usage.sessions_limit,\n        'usage_percentage': usage.usage_percentage\n    })\n\n    return {\n        \"current_usage\": usage.usage_percentage,\n        \"sessions_remaining\": usage.sessions_remaining,\n        \"status\": \"healthy\" if usage.usage_percentage &lt; 80 else \"warning\"\n    }\n\ndef send_alert(level: str, message: str):\n    \"\"\"Send alert to monitoring system\"\"\"\n    # Integrate with your alerting system (Slack, PagerDuty, etc.)\n    logger.info(f\"ALERT [{level}]: {message}\")\n</code></pre>"},{"location":"production/#health-monitoring","title":"Health Monitoring","text":"<pre><code>@agent.tool\ndef health_check() -&gt; dict:\n    \"\"\"Comprehensive health check\"\"\"\n\n    health_status = {\n        \"status\": \"healthy\",\n        \"checks\": {},\n        \"timestamp\": datetime.now().isoformat()\n    }\n\n    # Check DataVault connectivity\n    try:\n        agent.vault.store('health_check', {'test': True}, key='health_test')\n        agent.vault.delete('health_check', 'health_test')\n        health_status[\"checks\"][\"datavault\"] = \"healthy\"\n    except Exception as e:\n        health_status[\"checks\"][\"datavault\"] = f\"unhealthy: {e}\"\n        health_status[\"status\"] = \"degraded\"\n\n    # Check AI provider connectivity\n    try:\n        test_response = agent.chat(\"test\")\n        if test_response:\n            health_status[\"checks\"][\"ai_provider\"] = \"healthy\"\n        else:\n            health_status[\"checks\"][\"ai_provider\"] = \"unhealthy: no response\"\n            health_status[\"status\"] = \"degraded\"\n    except Exception as e:\n        health_status[\"checks\"][\"ai_provider\"] = f\"unhealthy: {e}\"\n        health_status[\"status\"] = \"unhealthy\"\n\n    # Check memory usage (if available)\n    import psutil\n    memory_percent = psutil.virtual_memory().percent\n    if memory_percent &gt; 90:\n        health_status[\"checks\"][\"memory\"] = f\"warning: {memory_percent}% used\"\n        health_status[\"status\"] = \"degraded\"\n    else:\n        health_status[\"checks\"][\"memory\"] = f\"healthy: {memory_percent}% used\"\n\n    return health_status\n</code></pre>"},{"location":"production/#security-best-practices","title":"Security Best Practices","text":""},{"location":"production/#input-validation","title":"Input Validation","text":"<pre><code>import re\nfrom typing import Union\n\n@agent.tool\ndef secure_user_input(email: str, message: str) -&gt; dict:\n    \"\"\"Securely handle user input\"\"\"\n\n    # Validate email format\n    email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    if not re.match(email_pattern, email):\n        return {\"error\": \"Invalid email format\"}\n\n    # Sanitize message\n    message = sanitize_text(message)\n\n    # Check message length\n    if len(message) &gt; 1000:\n        return {\"error\": \"Message too long (max 1000 characters)\"}\n\n    # Check for potentially harmful content\n    if contains_harmful_content(message):\n        return {\"error\": \"Message contains inappropriate content\"}\n\n    # Process safe input\n    return process_safe_input(email, message)\n\ndef sanitize_text(text: str) -&gt; str:\n    \"\"\"Remove potentially harmful characters\"\"\"\n    # Remove HTML tags\n    import html\n    text = html.escape(text)\n\n    # Remove excessive whitespace\n    text = ' '.join(text.split())\n\n    return text\n\ndef contains_harmful_content(text: str) -&gt; bool:\n    \"\"\"Check for harmful content patterns\"\"\"\n    harmful_patterns = [\n        r'&lt;script.*?&gt;.*?&lt;/script&gt;',\n        r'javascript:',\n        r'vbscript:',\n        r'onload\\s*=',\n        r'onerror\\s*='\n    ]\n\n    for pattern in harmful_patterns:\n        if re.search(pattern, text, re.IGNORECASE):\n            return True\n\n    return False\n</code></pre>"},{"location":"production/#api-key-security","title":"API Key Security","text":"<pre><code>import os\n\n# \u2705 Good: Use environment variables\nagent = Agent(\n    name=\"secure-agent\",\n    api_key=os.getenv(\"FLOWSTACK_API_KEY\"),\n    provider=\"openai\",\n    byok={\"api_key\": os.getenv(\"OPENAI_API_KEY\")}\n)\n\n# \u274c Bad: Hardcode API keys\n# agent = Agent(\n#     name=\"insecure-agent\", \n#     api_key=\"fs_abc123...\",  # Don't do this!\n#     byok={\"api_key\": \"sk-...\"}  # Don't do this!\n# )\n</code></pre>"},{"location":"production/#data-protection","title":"Data Protection","text":"<pre><code>@agent.tool\ndef protect_sensitive_data(user_data: dict) -&gt; dict:\n    \"\"\"Handle sensitive data securely\"\"\"\n\n    # Create a copy to avoid modifying original\n    safe_data = user_data.copy()\n\n    # Remove or mask sensitive fields\n    sensitive_fields = ['ssn', 'credit_card', 'password', 'api_key']\n    for field in sensitive_fields:\n        if field in safe_data:\n            if field == 'credit_card':\n                # Mask credit card (show last 4 digits)\n                safe_data[field] = f\"****-****-****-{safe_data[field][-4:]}\"\n            else:\n                # Remove other sensitive data\n                del safe_data[field]\n\n    # Log access for audit trail\n    logger.info(f\"Accessed user data for user: {safe_data.get('user_id', 'unknown')}\")\n\n    return {\"data\": safe_data, \"sensitive_fields_removed\": len(sensitive_fields)}\n</code></pre>"},{"location":"production/#scaling-considerations","title":"Scaling Considerations","text":""},{"location":"production/#high-traffic-handling","title":"High Traffic Handling","text":"<p>FlowStack automatically handles scaling, but you can optimize for high traffic:</p> <pre><code>@agent.tool\ndef high_traffic_optimized(request_data: dict) -&gt; dict:\n    \"\"\"Optimized for high-traffic scenarios\"\"\"\n\n    # Use caching aggressively\n    cache_key = generate_cache_key(request_data)\n    cached_result = agent.vault.retrieve('high_traffic_cache', key=cache_key)\n\n    if cached_result and not is_cache_expired(cached_result):\n        return {\"result\": cached_result['data'], \"cached\": True}\n\n    # Process with minimal resource usage\n    result = lightweight_processing(request_data)\n\n    # Cache with short TTL for high traffic\n    agent.vault.store('high_traffic_cache', {\n        'data': result,\n        'expires_at': (datetime.now() + timedelta(minutes=5)).isoformat()\n    }, key=cache_key)\n\n    return {\"result\": result, \"cached\": False}\n\ndef generate_cache_key(data: dict) -&gt; str:\n    \"\"\"Generate consistent cache key\"\"\"\n    import hashlib\n    key_data = json.dumps(data, sort_keys=True)\n    return hashlib.md5(key_data.encode()).hexdigest()\n</code></pre>"},{"location":"production/#resource-management","title":"Resource Management","text":"<pre><code>@agent.tool\ndef resource_aware_processing(large_dataset: list) -&gt; dict:\n    \"\"\"Process large datasets with resource awareness\"\"\"\n\n    # Check current system load\n    import psutil\n    cpu_percent = psutil.cpu_percent()\n    memory_percent = psutil.virtual_memory().percent\n\n    # Adjust processing based on resource availability\n    if cpu_percent &gt; 80 or memory_percent &gt; 80:\n        # Use smaller chunks when resources are constrained\n        chunk_size = 50\n        delay_between_chunks = 0.1\n    else:\n        # Use larger chunks when resources are available\n        chunk_size = 200\n        delay_between_chunks = 0\n\n    results = []\n    for i in range(0, len(large_dataset), chunk_size):\n        chunk = large_dataset[i:i + chunk_size]\n        chunk_result = process_chunk(chunk)\n        results.append(chunk_result)\n\n        # Optional delay to prevent resource exhaustion\n        if delay_between_chunks:\n            time.sleep(delay_between_chunks)\n\n    return {\n        \"processed_chunks\": len(results),\n        \"total_items\": len(large_dataset),\n        \"chunk_size_used\": chunk_size\n    }\n</code></pre>"},{"location":"production/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"production/#blue-green-deployment","title":"Blue-Green Deployment","text":"<pre><code># Deploy new version alongside existing\nnew_endpoint = agent.deploy(version=\"2.0.0\", strategy=\"blue_green\")\n\n# Test new version\nif test_new_version(new_endpoint):\n    # Switch traffic to new version\n    agent.promote_deployment(\"2.0.0\")\nelse:\n    # Rollback to previous version\n    agent.rollback_deployment()\n</code></pre>"},{"location":"production/#canary-deployment","title":"Canary Deployment","text":"<pre><code># Deploy to small percentage of traffic\nagent.deploy(\n    version=\"2.0.0\",\n    strategy=\"canary\",\n    traffic_percentage=10  # 10% of traffic\n)\n\n# Monitor metrics and gradually increase traffic\nif metrics_look_good():\n    agent.increase_canary_traffic(50)  # 50% of traffic\n\n    if still_looking_good():\n        agent.promote_canary()  # 100% of traffic\n</code></pre>"},{"location":"production/#cost-optimization","title":"Cost Optimization","text":""},{"location":"production/#smart-provider-usage","title":"Smart Provider Usage","text":"<pre><code>@agent.tool\ndef cost_optimized_routing(task: str, budget_per_session: float = 0.15) -&gt; dict:\n    \"\"\"Route tasks to optimize costs while maintaining quality\"\"\"\n\n    # Analyze task complexity\n    complexity = analyze_task_complexity(task)\n\n    if complexity == \"simple\" and budget_per_session &lt;= 0.10:\n        # Use cheapest option for simple tasks\n        agent.set_provider(\"openai\", byok={\"api_key\": os.getenv(\"OPENAI_KEY\")})\n        agent.set_model(\"gpt-3.5-turbo\")\n        estimated_cost = 0.05\n    elif complexity == \"medium\" and budget_per_session &lt;= 0.25:\n        # Use managed Bedrock for balanced cost/performance\n        agent.set_provider(\"bedrock\")\n        agent.set_model(Models.CLAUDE_35_SONNET)\n        estimated_cost = 0.20\n    elif complexity == \"complex\":\n        # Use best model regardless of cost\n        agent.set_provider(\"anthropic\", byok={\"api_key\": os.getenv(\"ANTHROPIC_KEY\")})\n        agent.set_model(\"claude-3-opus-20240229\")\n        estimated_cost = 0.35\n    else:\n        return {\"error\": f\"Task too expensive for budget of ${budget_per_session}\"}\n\n    response = agent.chat(task)\n\n    # Track actual costs\n    agent.vault.store('cost_tracking', {\n        'task': task,\n        'complexity': complexity,\n        'provider': agent.provider,\n        'model': agent.model,\n        'estimated_cost': estimated_cost,\n        'timestamp': datetime.now().isoformat()\n    })\n\n    return {\n        \"response\": response,\n        \"estimated_cost\": estimated_cost,\n        \"provider\": agent.provider\n    }\n</code></pre> <p>Ready for production? Start with our deployment guide or check the billing documentation to understand costs.</p>"},{"location":"quickstart/","title":"5-Minute Quickstart","text":"<p>Get your first agent from local development to production in under 5 minutes.</p>"},{"location":"quickstart/#step-1-install-flowstack-sdk","title":"Step 1: Install FlowStack SDK","text":"<pre><code>pip install flowstack\n</code></pre> <p>Virtual Environment Recommended</p> <pre><code>python -m venv flowstack-env\nsource flowstack-env/bin/activate  # On Windows: flowstack-env\\Scripts\\activate\npip install flowstack\n</code></pre>"},{"location":"quickstart/#step-2-get-your-api-key","title":"Step 2: Get Your API Key","text":"<ol> <li>Go to flowstack.fun</li> <li>Register your account (email verification required)</li> <li>Copy your API key starting with <code>fs_</code></li> </ol> <p>Free Tier</p> <p>New accounts get 25 free sessions per month. Perfect for testing!</p>"},{"location":"quickstart/#step-3-build-your-first-agent","title":"Step 3: Build Your First Agent","text":"<p>Create a file called <code>my_agent.py</code>:</p> my_agent.py<pre><code>from flowstack import Agent\n\n# Initialize your agent\nagent = Agent(\n    name=\"customer-helper\",\n    api_key=\"fs_your_api_key_here\"  # Replace with your actual key\n)\n\n# Add a tool - this is what makes your agent useful\n@agent.tool\ndef lookup_order(order_id: str) -&gt; dict:\n    \"\"\"Look up order status by ID\"\"\"\n    # In a real app, this would query your database\n    # For now, let's simulate some order data\n    orders = {\n        \"12345\": {\"status\": \"shipped\", \"tracking\": \"UPS123456789\", \"eta\": \"Tomorrow\"},\n        \"67890\": {\"status\": \"processing\", \"tracking\": None, \"eta\": \"2-3 days\"},\n        \"99999\": {\"status\": \"delivered\", \"tracking\": \"FEDEX987654321\", \"eta\": \"Completed\"}\n    }\n\n    order = orders.get(order_id)\n    if order:\n        return order\n    else:\n        return {\"error\": f\"Order {order_id} not found\"}\n\n@agent.tool  \ndef store_feedback(order_id: str, feedback: str) -&gt; dict:\n    \"\"\"Store customer feedback for an order\"\"\"\n    # Use DataVault to persist feedback\n    feedback_data = {\n        \"order_id\": order_id,\n        \"feedback\": feedback,\n        \"timestamp\": \"2024-01-15T10:30:00Z\"\n    }\n\n    # Store in DataVault (built-in persistence)\n    feedback_key = agent.vault.store('feedback', feedback_data)\n    return {\"message\": \"Feedback saved\", \"id\": feedback_key}\n\n# Test your agent locally first\nif __name__ == \"__main__\":\n    print(\"\ud83e\udd16 Testing customer helper agent...\")\n\n    # Test order lookup\n    response1 = agent.chat(\"What's the status of order 12345?\")\n    print(f\"Order Status: {response1}\")\n\n    # Test feedback storage\n    response2 = agent.chat(\"I want to leave feedback for order 12345: Great service!\")\n    print(f\"Feedback: {response2}\")\n\n    print(\"\\n\u2705 Local testing complete!\")\n</code></pre>"},{"location":"quickstart/#step-4-test-locally","title":"Step 4: Test Locally","text":"<p>Run your agent to make sure it works:</p> <pre><code>python my_agent.py\n</code></pre> <p>You should see output like:</p> <pre><code>\ud83e\udd16 Testing customer helper agent...\nOrder Status: I found order 12345! It has shipped with tracking number UPS123456789 and should arrive tomorrow.\nFeedback: Thank you for your feedback! I've saved your comment about great service for order 12345.\n\n\u2705 Local testing complete!\n</code></pre> <p>It Works!</p> <p>Your agent is now running locally with tools and DataVault persistence. Next, let's make it live!</p>"},{"location":"quickstart/#step-5-deploy-to-production","title":"Step 5: Deploy to Production","text":"<p>Add this to the bottom of your <code>my_agent.py</code> file:</p> my_agent.py<pre><code># ... your existing code above ...\n\n# Deploy to production\nif __name__ == \"__main__\":\n    # Test locally first (existing code)\n    # ... \n\n    # Deploy to production\n    print(\"\\n\ud83d\ude80 Deploying to production...\")\n    endpoint = agent.deploy()\n    print(f\"\u2705 Agent deployed successfully!\")\n    print(f\"Production endpoint: {endpoint}\")\n    print(f\"Chat endpoint: {endpoint}/chat\")\n</code></pre> <p>Run the deployment:</p> <pre><code>python my_agent.py\n</code></pre> <p>You'll see:</p> <pre><code>\ud83d\ude80 Deploying to production...\n\u2705 Agent deployed successfully!\nProduction endpoint: https://api.flowstack.fun/agents/customer-helper\nChat endpoint: https://api.flowstack.fun/agents/customer-helper/chat\n</code></pre>"},{"location":"quickstart/#step-6-test-your-live-agent","title":"Step 6: Test Your Live Agent","text":"<p>Your agent is now running in production! Test it with curl:</p> Test Order LookupTest Feedback StoragePython Client <pre><code>curl -X POST https://api.flowstack.fun/agents/customer-helper/chat \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: fs_your_api_key_here\" \\\n  -d '{\n    \"message\": \"Check the status of order 67890\"\n  }'\n</code></pre> <pre><code>curl -X POST https://api.flowstack.fun/agents/customer-helper/chat \\\n  -H \"Content-Type: application/json\" \\\n  -H \"X-API-Key: fs_your_api_key_here\" \\\n  -d '{\n    \"message\": \"I want to give feedback for order 12345: Fast delivery!\"\n  }'\n</code></pre> <pre><code>import requests\n\nresponse = requests.post(\n    \"https://api.flowstack.fun/agents/customer-helper/chat\",\n    headers={\n        \"Content-Type\": \"application/json\",\n        \"X-API-Key\": \"fs_your_api_key_here\"\n    },\n    json={\"message\": \"What's the status of order 99999?\"}\n)\n\nprint(response.json())\n</code></pre>"},{"location":"quickstart/#congratulations","title":"\ud83c\udf89 Congratulations!","text":"<p>You just built and deployed a production AI agent in under 5 minutes! Your agent:</p> <p>\u2705 Has custom tools - <code>lookup_order()</code> and <code>store_feedback()</code> \u2705 Uses persistent storage - DataVault automatically stores feedback \u2705 Runs in production - Live HTTPS endpoint ready for real traffic \u2705 Scales automatically - From 0 to thousands of requests \u2705 Handles authentication - Secured with your API key  </p>"},{"location":"quickstart/#what-happens-next","title":"What Happens Next?","text":"<ul> <li> <p> Learn DataVault</p> <p>Understand how to store and query data in your agents</p> </li> <li> <p> Core Concepts</p> <p>Learn about agents, tools, deployment, and sessions</p> </li> <li> <p> See More Examples</p> <p>Chatbots, automation agents, and advanced patterns</p> </li> <li> <p> Monitor Usage</p> <p>Track your usage, understand billing, and upgrade plans</p> </li> </ul>"},{"location":"quickstart/#check-your-usage","title":"Check Your Usage","text":"<p>See how many sessions you've used:</p> <pre><code>usage = agent.get_usage()\nprint(f\"Sessions used: {usage.sessions_used}/{usage.sessions_limit}\")\nprint(f\"Sessions remaining: {usage.sessions_remaining}\")\n</code></pre>"},{"location":"quickstart/#common-next-steps","title":"Common Next Steps","text":""},{"location":"quickstart/#add-more-tools","title":"Add More Tools","text":"<pre><code>@agent.tool\ndef cancel_order(order_id: str) -&gt; dict:\n    \"\"\"Cancel an order if possible\"\"\"\n    # Your cancellation logic here\n    pass\n\n@agent.tool\ndef track_shipment(tracking_number: str) -&gt; dict:\n    \"\"\"Get detailed tracking information\"\"\"\n    # Integration with shipping APIs\n    pass\n</code></pre>"},{"location":"quickstart/#store-more-data","title":"Store More Data","text":"<pre><code># Store user preferences\nagent.vault.store('users', {\n    'user_id': 'user_123',\n    'preferences': {'notifications': True, 'language': 'en'}\n})\n\n# Store conversation history\nagent.vault.store('conversations', {\n    'user_id': 'user_123',\n    'messages': [...],\n    'timestamp': datetime.now()\n})\n</code></pre>"},{"location":"quickstart/#switch-ai-providers","title":"Switch AI Providers","text":"<pre><code># Use your own OpenAI key (no markup)\nagent = Agent(\n    name=\"my-agent\",\n    api_key=\"fs_...\",\n    provider=\"openai\",\n    model=\"gpt-4\",\n    byok={\"api_key\": \"sk-your-openai-key\"}\n)\n</code></pre> <p>Ready to build something amazing? Check out our recipes for inspiration!</p>"},{"location":"recipes/automation-agent/","title":"Recipe: Automation Agent (Zapier Killer)","text":"<p>Build intelligent workflow automation that remembers state, makes decisions, and handles complex multi-step processes.</p> <p>Perfect for Automation Enthusiasts</p> <p>This recipe shows how to build stateful automation that's more powerful than Zapier or n8n, with AI decision-making and persistent memory.</p>"},{"location":"recipes/automation-agent/#what-youll-build","title":"What You'll Build","text":"<p>An automation agent that can:</p> <ul> <li>\ud83d\udd04 Handle multi-step workflows with conditional logic</li> <li>\ud83e\udde0 Make intelligent decisions based on data and context</li> <li>\ud83d\udcbe Remember state between workflow runs</li> <li>\ud83d\udcca Track and analyze workflow performance</li> <li>\ud83d\udd17 Integrate with any API or service</li> <li>\u26a1 Trigger on schedules or external events</li> </ul>"},{"location":"recipes/automation-agent/#the-complete-code","title":"The Complete Code","text":"automation_agent.py<pre><code>from flowstack import Agent\nfrom datetime import datetime, timedelta\nimport json\nimport hashlib\n\n# Initialize the automation agent\nautomation = Agent(\n    name=\"workflow-automation\",\n    api_key=\"fs_your_api_key_here\",\n    system_prompt=\"\"\"You are an intelligent workflow automation agent. You can:\n    - Execute multi-step workflows with decision points\n    - Remember workflow state and history\n    - Make smart decisions based on data and context\n    - Handle errors gracefully and retry operations\n    - Learn from past workflow executions to improve performance\n\n    Always think through workflows step by step and use the available tools effectively.\"\"\"\n)\n\n# Tool 1: Lead Scoring and CRM Automation\n@automation.tool\ndef process_new_lead(lead_data: dict) -&gt; dict:\n    \"\"\"Process a new lead through the qualification workflow\"\"\"\n\n    lead_id = lead_data.get('id') or f\"lead_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n\n    # Calculate lead score\n    score = calculate_lead_score(lead_data)\n\n    # Determine workflow path based on score\n    workflow_steps = []\n\n    if score &gt;= 80:\n        # High-value lead: immediate personal outreach\n        workflow_steps = [\n            'send_immediate_alert_to_sales',\n            'create_high_priority_crm_record', \n            'schedule_personal_followup',\n            'add_to_hot_leads_sequence'\n        ]\n        priority = 'high'\n    elif score &gt;= 50:\n        # Medium lead: nurture sequence\n        workflow_steps = [\n            'create_crm_record',\n            'add_to_nurture_sequence',\n            'schedule_followup_in_3_days',\n            'send_educational_content'\n        ]\n        priority = 'medium'\n    else:\n        # Low score: basic tracking\n        workflow_steps = [\n            'create_basic_crm_record',\n            'add_to_newsletter',\n            'schedule_followup_in_2_weeks'\n        ]\n        priority = 'low'\n\n    # Create workflow instance\n    workflow = {\n        'id': f\"workflow_{lead_id}\",\n        'lead_id': lead_id,\n        'lead_data': lead_data,\n        'score': score,\n        'priority': priority,\n        'steps': workflow_steps,\n        'current_step': 0,\n        'status': 'in_progress',\n        'created_at': datetime.now().isoformat(),\n        'results': []\n    }\n\n    # Store workflow state\n    automation.vault.store('workflows', workflow, key=workflow['id'])\n\n    # Execute first step\n    result = execute_workflow_step(workflow['id'])\n\n    return {\n        'lead_id': lead_id,\n        'workflow_id': workflow['id'],\n        'score': score,\n        'priority': priority,\n        'first_step_result': result\n    }\n\ndef calculate_lead_score(lead_data: dict) -&gt; int:\n    \"\"\"Calculate lead score based on various factors\"\"\"\n    score = 0\n\n    # Company size scoring\n    company_size = lead_data.get('company_size', 0)\n    if company_size &gt; 1000:\n        score += 30\n    elif company_size &gt; 100:\n        score += 20\n    elif company_size &gt; 10:\n        score += 10\n\n    # Industry scoring\n    high_value_industries = ['technology', 'finance', 'healthcare', 'manufacturing']\n    if lead_data.get('industry', '').lower() in high_value_industries:\n        score += 25\n\n    # Role scoring\n    decision_maker_roles = ['ceo', 'cto', 'vp', 'director', 'head of', 'chief']\n    role = lead_data.get('role', '').lower()\n    if any(title in role for title in decision_maker_roles):\n        score += 30\n    elif 'manager' in role:\n        score += 15\n\n    # Engagement scoring\n    if lead_data.get('downloaded_whitepaper'):\n        score += 15\n    if lead_data.get('attended_webinar'):\n        score += 20\n    if lead_data.get('requested_demo'):\n        score += 35\n\n    # Budget indication\n    if lead_data.get('budget_indicated', 0) &gt; 50000:\n        score += 25\n    elif lead_data.get('budget_indicated', 0) &gt; 10000:\n        score += 15\n\n    return min(score, 100)  # Cap at 100\n\n@automation.tool\ndef execute_workflow_step(workflow_id: str) -&gt; dict:\n    \"\"\"Execute the next step in a workflow\"\"\"\n\n    # Get workflow state\n    workflow = automation.vault.retrieve('workflows', key=workflow_id)\n    if not workflow:\n        return {'error': 'Workflow not found'}\n\n    if workflow['status'] != 'in_progress':\n        return {'message': f'Workflow is {workflow[\"status\"]}', 'workflow_id': workflow_id}\n\n    # Check if workflow is complete\n    if workflow['current_step'] &gt;= len(workflow['steps']):\n        workflow['status'] = 'completed'\n        workflow['completed_at'] = datetime.now().isoformat()\n        automation.vault.store('workflows', workflow, key=workflow_id)\n        return {'message': 'Workflow completed', 'workflow_id': workflow_id}\n\n    # Execute current step\n    current_step = workflow['steps'][workflow['current_step']]\n    step_result = execute_step_action(current_step, workflow)\n\n    # Record result\n    step_record = {\n        'step': current_step,\n        'step_number': workflow['current_step'],\n        'result': step_result,\n        'executed_at': datetime.now().isoformat()\n    }\n    workflow['results'].append(step_record)\n\n    # Move to next step\n    workflow['current_step'] += 1\n    workflow['updated_at'] = datetime.now().isoformat()\n\n    # Update workflow state\n    automation.vault.store('workflows', workflow, key=workflow_id)\n\n    return {\n        'workflow_id': workflow_id,\n        'step_executed': current_step,\n        'step_result': step_result,\n        'next_step': workflow['steps'][workflow['current_step']] if workflow['current_step'] &lt; len(workflow['steps']) else 'completed',\n        'progress': f\"{workflow['current_step']}/{len(workflow['steps'])}\"\n    }\n\ndef execute_step_action(step: str, workflow: dict) -&gt; dict:\n    \"\"\"Execute a specific workflow step action\"\"\"\n\n    lead_data = workflow['lead_data']\n\n    if step == 'send_immediate_alert_to_sales':\n        # In real implementation, this would send Slack/email alert\n        return {\n            'action': 'sales_alert_sent',\n            'message': f\"High-value lead alert sent for {lead_data.get('name', 'Unknown')}\",\n            'success': True\n        }\n\n    elif step == 'create_high_priority_crm_record':\n        # In real implementation, this would call CRM API (Salesforce, HubSpot, etc.)\n        crm_record = {\n            'lead_id': workflow['lead_id'],\n            'name': lead_data.get('name'),\n            'company': lead_data.get('company'),\n            'email': lead_data.get('email'),\n            'priority': 'high',\n            'score': workflow['score'],\n            'created_at': datetime.now().isoformat()\n        }\n        automation.vault.store('crm_records', crm_record, key=workflow['lead_id'])\n        return {'action': 'crm_record_created', 'priority': 'high', 'success': True}\n\n    elif step == 'schedule_personal_followup':\n        # Schedule followup task\n        followup = {\n            'lead_id': workflow['lead_id'],\n            'type': 'personal_call',\n            'scheduled_for': (datetime.now() + timedelta(hours=2)).isoformat(),\n            'assigned_to': 'sales_team',\n            'priority': 'high'\n        }\n        automation.vault.store('followup_tasks', followup, key=f\"followup_{workflow['lead_id']}\")\n        return {'action': 'followup_scheduled', 'scheduled_for': followup['scheduled_for'], 'success': True}\n\n    elif step == 'add_to_nurture_sequence':\n        # Add to email nurture sequence\n        sequence = {\n            'lead_id': workflow['lead_id'],\n            'sequence_type': 'nurture',\n            'current_email': 1,\n            'total_emails': 5,\n            'started_at': datetime.now().isoformat(),\n            'next_email_date': (datetime.now() + timedelta(days=1)).isoformat()\n        }\n        automation.vault.store('email_sequences', sequence, key=f\"seq_{workflow['lead_id']}\")\n        return {'action': 'added_to_nurture', 'sequence_length': 5, 'success': True}\n\n    elif step == 'send_educational_content':\n        # Send relevant educational content\n        content = {\n            'lead_id': workflow['lead_id'],\n            'content_type': 'industry_guide',\n            'title': f\"Best Practices for {lead_data.get('industry', 'Your Industry')}\",\n            'sent_at': datetime.now().isoformat()\n        }\n        automation.vault.store('content_delivered', content, key=f\"content_{workflow['lead_id']}\")\n        return {'action': 'content_sent', 'content_type': 'industry_guide', 'success': True}\n\n    else:\n        # Default action for unhandled steps\n        return {'action': step, 'message': f'Step {step} executed', 'success': True}\n\n# Tool 2: E-commerce Order Processing Automation\n@automation.tool\ndef process_order_workflow(order_data: dict) -&gt; dict:\n    \"\"\"Process an e-commerce order through fulfillment workflow\"\"\"\n\n    order_id = order_data.get('id', f\"order_{datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n\n    # Determine workflow based on order characteristics\n    workflow_steps = ['validate_payment', 'check_inventory', 'reserve_items']\n\n    # Add conditional steps based on order\n    if order_data.get('total', 0) &gt; 1000:\n        workflow_steps.append('fraud_check')\n\n    if order_data.get('shipping_country') != 'US':\n        workflow_steps.extend(['customs_documentation', 'international_shipping_calculation'])\n\n    if any(item.get('custom_engraving') for item in order_data.get('items', [])):\n        workflow_steps.append('custom_production_queue')\n\n    workflow_steps.extend([\n        'generate_shipping_label',\n        'send_confirmation_email',\n        'update_customer_record'\n    ])\n\n    # Create workflow\n    workflow = {\n        'id': f\"order_workflow_{order_id}\",\n        'order_id': order_id,\n        'order_data': order_data,\n        'steps': workflow_steps,\n        'current_step': 0,\n        'status': 'in_progress',\n        'created_at': datetime.now().isoformat(),\n        'results': []\n    }\n\n    automation.vault.store('order_workflows', workflow, key=workflow['id'])\n\n    return {\n        'order_id': order_id,\n        'workflow_id': workflow['id'],\n        'total_steps': len(workflow_steps),\n        'message': 'Order workflow started'\n    }\n\n# Tool 3: Content Publishing Automation\n@automation.tool\ndef create_content_workflow(content_request: dict) -&gt; dict:\n    \"\"\"Create and execute content publishing workflow\"\"\"\n\n    content_id = content_request.get('id', f\"content_{datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n\n    # Determine workflow based on content type\n    content_type = content_request.get('type', 'blog_post')\n\n    if content_type == 'blog_post':\n        workflow_steps = [\n            'research_keywords',\n            'generate_outline',\n            'write_draft',\n            'add_images',\n            'seo_optimization',\n            'schedule_publication',\n            'promote_on_social'\n        ]\n    elif content_type == 'social_media':\n        workflow_steps = [\n            'generate_post_variations',\n            'create_visual_assets',\n            'schedule_across_platforms',\n            'track_engagement'\n        ]\n    elif content_type == 'email_newsletter':\n        workflow_steps = [\n            'gather_content_pieces',\n            'create_email_template',\n            'segment_audience',\n            'schedule_send',\n            'track_performance'\n        ]\n\n    workflow = {\n        'id': f\"content_workflow_{content_id}\",\n        'content_id': content_id,\n        'content_request': content_request,\n        'steps': workflow_steps,\n        'current_step': 0,\n        'status': 'in_progress',\n        'created_at': datetime.now().isoformat(),\n        'results': []\n    }\n\n    automation.vault.store('content_workflows', workflow, key=workflow['id'])\n\n    return {\n        'content_id': content_id,\n        'workflow_id': workflow['id'],\n        'content_type': content_type,\n        'steps': workflow_steps\n    }\n\n# Tool 4: Workflow Analytics and Optimization\n@automation.tool\ndef analyze_workflow_performance(workflow_type: str = None, days: int = 30) -&gt; dict:\n    \"\"\"Analyze workflow performance and identify optimization opportunities\"\"\"\n\n    cutoff_date = (datetime.now() - timedelta(days=days)).isoformat()\n\n    # Get workflows from the specified period\n    query = {'created_at': {'$gte': cutoff_date}}\n    if workflow_type:\n        query['id'] = {'$regex': workflow_type}\n\n    workflows = automation.vault.query('workflows', query)\n\n    if not workflows:\n        return {'message': 'No workflows found for analysis', 'period_days': days}\n\n    # Calculate performance metrics\n    total_workflows = len(workflows)\n    completed_workflows = [w for w in workflows if w.get('status') == 'completed']\n    completion_rate = (len(completed_workflows) / total_workflows) * 100\n\n    # Calculate average execution time for completed workflows\n    execution_times = []\n    for workflow in completed_workflows:\n        if 'completed_at' in workflow:\n            start = datetime.fromisoformat(workflow['created_at'])\n            end = datetime.fromisoformat(workflow['completed_at'])\n            execution_times.append((end - start).total_seconds())\n\n    avg_execution_time = sum(execution_times) / len(execution_times) if execution_times else 0\n\n    # Find most common failure points\n    failure_steps = {}\n    for workflow in workflows:\n        if workflow.get('status') == 'failed':\n            last_step = workflow.get('results', [])[-1] if workflow.get('results') else None\n            if last_step:\n                step_name = last_step.get('step', 'unknown')\n                failure_steps[step_name] = failure_steps.get(step_name, 0) + 1\n\n    # Performance by priority (for lead workflows)\n    performance_by_priority = {}\n    for workflow in workflows:\n        priority = workflow.get('priority', 'unknown')\n        if priority not in performance_by_priority:\n            performance_by_priority[priority] = {'total': 0, 'completed': 0}\n        performance_by_priority[priority]['total'] += 1\n        if workflow.get('status') == 'completed':\n            performance_by_priority[priority]['completed'] += 1\n\n    return {\n        'analysis_period_days': days,\n        'total_workflows': total_workflows,\n        'completion_rate': round(completion_rate, 2),\n        'avg_execution_time_seconds': round(avg_execution_time, 2),\n        'common_failure_steps': sorted(failure_steps.items(), key=lambda x: x[1], reverse=True)[:5],\n        'performance_by_priority': performance_by_priority,\n        'recommendations': generate_optimization_recommendations(workflows)\n    }\n\ndef generate_optimization_recommendations(workflows: list) -&gt; list:\n    \"\"\"Generate recommendations for workflow optimization\"\"\"\n    recommendations = []\n\n    # Check for consistently failing steps\n    all_failures = {}\n    for workflow in workflows:\n        if workflow.get('status') == 'failed':\n            for result in workflow.get('results', []):\n                if not result.get('result', {}).get('success', True):\n                    step = result.get('step')\n                    all_failures[step] = all_failures.get(step, 0) + 1\n\n    if all_failures:\n        most_failing_step = max(all_failures.items(), key=lambda x: x[1])\n        recommendations.append({\n            'type': 'reliability',\n            'priority': 'high',\n            'message': f\"Step '{most_failing_step[0]}' fails frequently ({most_failing_step[1]} times). Consider adding retry logic or error handling.\"\n        })\n\n    # Check for slow workflows\n    slow_workflows = [w for w in workflows if w.get('status') == 'completed' and \n                     'completed_at' in w and 'created_at' in w]\n\n    if slow_workflows:\n        execution_times = []\n        for w in slow_workflows:\n            start = datetime.fromisoformat(w['created_at'])\n            end = datetime.fromisoformat(w['completed_at'])\n            execution_times.append((end - start).total_seconds())\n\n        if execution_times and max(execution_times) &gt; 3600:  # More than 1 hour\n            recommendations.append({\n                'type': 'performance',\n                'priority': 'medium',\n                'message': f\"Some workflows take over 1 hour. Consider parallelizing steps or optimizing slow operations.\"\n            })\n\n    # Check completion rates\n    completion_rate = len([w for w in workflows if w.get('status') == 'completed']) / len(workflows) * 100\n    if completion_rate &lt; 80:\n        recommendations.append({\n            'type': 'completion',\n            'priority': 'high',\n            'message': f\"Low completion rate ({completion_rate:.1f}%). Review failed workflows and add better error handling.\"\n        })\n\n    return recommendations\n\n# Tool 5: Scheduled Workflow Execution\n@automation.tool\ndef schedule_workflow_execution(workflow_type: str, schedule: str, params: dict = None) -&gt; dict:\n    \"\"\"Schedule a workflow to run on a specific schedule\"\"\"\n\n    schedule_id = f\"schedule_{workflow_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n\n    scheduled_task = {\n        'id': schedule_id,\n        'workflow_type': workflow_type,\n        'schedule': schedule,  # e.g., 'daily', 'weekly', 'hourly'\n        'params': params or {},\n        'created_at': datetime.now().isoformat(),\n        'last_run': None,\n        'next_run': calculate_next_run_time(schedule),\n        'status': 'active'\n    }\n\n    automation.vault.store('scheduled_workflows', scheduled_task, key=schedule_id)\n\n    return {\n        'schedule_id': schedule_id,\n        'workflow_type': workflow_type,\n        'schedule': schedule,\n        'next_run': scheduled_task['next_run'],\n        'message': 'Workflow scheduled successfully'\n    }\n\ndef calculate_next_run_time(schedule: str) -&gt; str:\n    \"\"\"Calculate the next run time based on schedule\"\"\"\n    now = datetime.now()\n\n    if schedule == 'hourly':\n        next_run = now + timedelta(hours=1)\n    elif schedule == 'daily':\n        next_run = now + timedelta(days=1)\n    elif schedule == 'weekly':\n        next_run = now + timedelta(weeks=1)\n    elif schedule == 'monthly':\n        next_run = now + timedelta(days=30)\n    else:\n        # Default to daily\n        next_run = now + timedelta(days=1)\n\n    return next_run.isoformat()\n\n# Test the automation agent\ndef test_automation():\n    \"\"\"Test the automation agent with sample workflows\"\"\"\n    print(\"\ud83e\udd16 Testing Workflow Automation Agent\")\n    print(\"=\" * 50)\n\n    # Test 1: Lead processing workflow\n    print(\"\\n1. Testing lead processing workflow...\")\n    sample_lead = {\n        'id': 'lead_001',\n        'name': 'John Smith',\n        'email': 'john@techcorp.com',\n        'company': 'TechCorp Inc',\n        'role': 'CTO',\n        'company_size': 500,\n        'industry': 'technology',\n        'downloaded_whitepaper': True,\n        'requested_demo': True,\n        'budget_indicated': 75000\n    }\n\n    response = automation.chat(f\"Process this new lead: {json.dumps(sample_lead)}\")\n    print(f\"Lead Processing: {response}\")\n\n    # Test 2: Order processing\n    print(\"\\n2. Testing order processing workflow...\")\n    sample_order = {\n        'id': 'order_001',\n        'customer_id': 'cust_123',\n        'total': 1250.00,\n        'shipping_country': 'Canada',\n        'items': [\n            {'id': 'item_1', 'name': 'Laptop', 'custom_engraving': True},\n            {'id': 'item_2', 'name': 'Mouse', 'custom_engraving': False}\n        ]\n    }\n\n    response = automation.chat(f\"Process this order: {json.dumps(sample_order)}\")\n    print(f\"Order Processing: {response}\")\n\n    # Test 3: Analytics\n    print(\"\\n3. Testing workflow analytics...\")\n    response = automation.chat(\"Analyze workflow performance for the last 7 days\")\n    print(f\"Analytics: {response}\")\n\n    print(\"\\n\u2705 Automation testing complete!\")\n\n# Deploy the automation agent\ndef deploy_automation():\n    \"\"\"Deploy the automation agent to production\"\"\"\n    print(\"\\n\ud83d\ude80 Deploying automation agent...\")\n\n    endpoint = automation.deploy()\n\n    print(f\"\u2705 Automation agent deployed!\")\n    print(f\"Webhook URL: {endpoint}/chat\")\n    print(f\"API endpoint: {endpoint}\")\n\n    print(\"\\n\ud83d\udcdd Integration examples:\")\n    print(\"\u2022 Webhook for new leads: POST to endpoint with lead data\")\n    print(\"\u2022 Order processing: POST to endpoint with order data\")\n    print(\"\u2022 Scheduled execution: Set up cron jobs to trigger workflows\")\n    print(\"\u2022 Analytics API: GET requests for performance data\")\n\n    return endpoint\n\nif __name__ == \"__main__\":\n    # Run tests\n    test_automation()\n\n    # Deploy\n    deploy_choice = input(\"\\nDeploy automation agent? (y/N): \")\n    if deploy_choice.lower() == 'y':\n        deploy_automation()\n</code></pre>"},{"location":"recipes/automation-agent/#integration-examples","title":"Integration Examples","text":""},{"location":"recipes/automation-agent/#webhook-for-new-leads","title":"Webhook for New Leads","text":"lead_webhook.py<pre><code>from flask import Flask, request, jsonify\nimport requests\n\napp = Flask(__name__)\n\nAUTOMATION_ENDPOINT = \"https://api.flowstack.fun/agents/workflow-automation/chat\"\nFLOWSTACK_API_KEY = \"fs_your_api_key_here\"\n\n@app.route('/webhook/new-lead', methods=['POST'])\ndef handle_new_lead():\n    \"\"\"Handle new lead from your website form or CRM\"\"\"\n\n    lead_data = request.json\n\n    # Send to FlowStack automation agent\n    response = requests.post(AUTOMATION_ENDPOINT,\n        headers={\n            'Content-Type': 'application/json',\n            'X-API-Key': FLOWSTACK_API_KEY\n        },\n        json={\n            'message': f\"Process this new lead: {json.dumps(lead_data)}\"\n        }\n    )\n\n    if response.status_code == 200:\n        result = response.json()\n        return jsonify({\n            'status': 'success',\n            'message': 'Lead processing workflow started',\n            'workflow_info': result\n        })\n    else:\n        return jsonify({\n            'status': 'error',\n            'message': 'Failed to start workflow'\n        }), 500\n\nif __name__ == '__main__':\n    app.run(port=5000)\n</code></pre>"},{"location":"recipes/automation-agent/#scheduled-workflow-runner","title":"Scheduled Workflow Runner","text":"scheduler.py<pre><code>import schedule\nimport time\nimport requests\nimport json\n\nAUTOMATION_ENDPOINT = \"https://api.flowstack.fun/agents/workflow-automation/chat\"\nFLOWSTACK_API_KEY = \"fs_your_api_key_here\"\n\ndef run_daily_analytics():\n    \"\"\"Run daily workflow analytics\"\"\"\n    response = requests.post(AUTOMATION_ENDPOINT,\n        headers={\n            'Content-Type': 'application/json',\n            'X-API-Key': FLOWSTACK_API_KEY\n        },\n        json={\n            'message': 'Analyze workflow performance for the last 24 hours and send report'\n        }\n    )\n    print(f\"Daily analytics result: {response.json()}\")\n\ndef run_lead_nurture_sequence():\n    \"\"\"Trigger nurture sequence processing\"\"\"\n    response = requests.post(AUTOMATION_ENDPOINT,\n        headers={\n            'Content-Type': 'application/json',\n            'X-API-Key': FLOWSTACK_API_KEY\n        },\n        json={\n            'message': 'Process all pending nurture sequence emails'\n        }\n    )\n    print(f\"Nurture sequence result: {response.json()}\")\n\n# Schedule tasks\nschedule.every().day.at(\"09:00\").do(run_daily_analytics)\nschedule.every().hour.do(run_lead_nurture_sequence)\n\n# Keep the scheduler running\nwhile True:\n    schedule.run_pending()\n    time.sleep(60)\n</code></pre>"},{"location":"recipes/automation-agent/#advanced-workflow-patterns","title":"Advanced Workflow Patterns","text":""},{"location":"recipes/automation-agent/#conditional-branching","title":"Conditional Branching","text":"<pre><code>@automation.tool\ndef execute_conditional_workflow(data: dict, conditions: dict) -&gt; dict:\n    \"\"\"Execute workflow with conditional branching\"\"\"\n\n    workflow_id = f\"conditional_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n\n    # Evaluate conditions to determine path\n    if conditions.get('customer_value') == 'high':\n        workflow_path = 'vip_customer_path'\n        steps = ['assign_account_manager', 'send_welcome_package', 'schedule_onboarding_call']\n    elif conditions.get('product_interest') == 'enterprise':\n        workflow_path = 'enterprise_sales_path'\n        steps = ['qualify_enterprise_needs', 'generate_custom_proposal', 'schedule_demo']\n    else:\n        workflow_path = 'standard_path'\n        steps = ['send_welcome_email', 'add_to_newsletter', 'schedule_followup']\n\n    workflow = {\n        'id': workflow_id,\n        'path': workflow_path,\n        'data': data,\n        'conditions': conditions,\n        'steps': steps,\n        'current_step': 0,\n        'status': 'in_progress',\n        'created_at': datetime.now().isoformat()\n    }\n\n    automation.vault.store('conditional_workflows', workflow, key=workflow_id)\n\n    return {\n        'workflow_id': workflow_id,\n        'selected_path': workflow_path,\n        'steps': steps,\n        'message': f'Conditional workflow started with path: {workflow_path}'\n    }\n</code></pre>"},{"location":"recipes/automation-agent/#parallel-execution","title":"Parallel Execution","text":"<pre><code>@automation.tool\ndef execute_parallel_workflow(tasks: list) -&gt; dict:\n    \"\"\"Execute multiple workflow tasks in parallel\"\"\"\n\n    workflow_id = f\"parallel_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n\n    # Create parallel task records\n    parallel_tasks = []\n    for i, task in enumerate(tasks):\n        task_record = {\n            'id': f\"{workflow_id}_task_{i}\",\n            'task_data': task,\n            'status': 'pending',\n            'created_at': datetime.now().isoformat()\n        }\n        parallel_tasks.append(task_record)\n        automation.vault.store('parallel_tasks', task_record, key=task_record['id'])\n\n    workflow = {\n        'id': workflow_id,\n        'type': 'parallel',\n        'total_tasks': len(tasks),\n        'completed_tasks': 0,\n        'failed_tasks': 0,\n        'task_ids': [task['id'] for task in parallel_tasks],\n        'status': 'in_progress',\n        'created_at': datetime.now().isoformat()\n    }\n\n    automation.vault.store('parallel_workflows', workflow, key=workflow_id)\n\n    return {\n        'workflow_id': workflow_id,\n        'total_tasks': len(tasks),\n        'task_ids': [task['id'] for task in parallel_tasks],\n        'message': 'Parallel workflow started'\n    }\n</code></pre>"},{"location":"recipes/automation-agent/#error-handling-and-retry-logic","title":"Error Handling and Retry Logic","text":"<pre><code>@automation.tool\ndef execute_workflow_with_retry(workflow_id: str, max_retries: int = 3) -&gt; dict:\n    \"\"\"Execute workflow step with retry logic for failed operations\"\"\"\n\n    workflow = automation.vault.retrieve('workflows', key=workflow_id)\n    if not workflow:\n        return {'error': 'Workflow not found'}\n\n    current_step = workflow['steps'][workflow['current_step']]\n    retry_count = workflow.get('retry_count', 0)\n\n    try:\n        # Attempt to execute step\n        result = execute_step_action(current_step, workflow)\n\n        if result.get('success'):\n            # Success - move to next step\n            workflow['current_step'] += 1\n            workflow['retry_count'] = 0  # Reset retry count\n            workflow['updated_at'] = datetime.now().isoformat()\n            automation.vault.store('workflows', workflow, key=workflow_id)\n\n            return {\n                'success': True,\n                'step': current_step,\n                'result': result,\n                'next_step': workflow['steps'][workflow['current_step']] if workflow['current_step'] &lt; len(workflow['steps']) else 'completed'\n            }\n        else:\n            # Step failed - check if we should retry\n            if retry_count &lt; max_retries:\n                workflow['retry_count'] = retry_count + 1\n                workflow['last_retry_at'] = datetime.now().isoformat()\n                automation.vault.store('workflows', workflow, key=workflow_id)\n\n                return {\n                    'success': False,\n                    'step': current_step,\n                    'result': result,\n                    'retry_count': workflow['retry_count'],\n                    'max_retries': max_retries,\n                    'message': f'Step failed, will retry ({workflow[\"retry_count\"]}/{max_retries})'\n                }\n            else:\n                # Max retries exceeded - mark workflow as failed\n                workflow['status'] = 'failed'\n                workflow['failed_at'] = datetime.now().isoformat()\n                workflow['failure_reason'] = f'Step {current_step} failed after {max_retries} retries'\n                automation.vault.store('workflows', workflow, key=workflow_id)\n\n                return {\n                    'success': False,\n                    'step': current_step,\n                    'result': result,\n                    'message': f'Workflow failed: Step {current_step} failed after {max_retries} retries'\n                }\n\n    except Exception as e:\n        # Unexpected error\n        workflow['status'] = 'error'\n        workflow['error_at'] = datetime.now().isoformat()\n        workflow['error_message'] = str(e)\n        automation.vault.store('workflows', workflow, key=workflow_id)\n\n        return {\n            'success': False,\n            'step': current_step,\n            'error': str(e),\n            'message': 'Workflow encountered an unexpected error'\n        }\n</code></pre>"},{"location":"recipes/automation-agent/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"recipes/automation-agent/#workflow-dashboard","title":"Workflow Dashboard","text":"<pre><code>@automation.tool\ndef get_workflow_dashboard() -&gt; dict:\n    \"\"\"Get real-time workflow dashboard data\"\"\"\n\n    # Active workflows\n    active_workflows = automation.vault.query('workflows', {'status': 'in_progress'})\n\n    # Failed workflows in last 24 hours\n    yesterday = (datetime.now() - timedelta(days=1)).isoformat()\n    recent_failures = automation.vault.query('workflows', {\n        'status': 'failed',\n        'failed_at': {'$gte': yesterday}\n    })\n\n    # Completion stats for last 7 days\n    week_ago = (datetime.now() - timedelta(days=7)).isoformat()\n    recent_workflows = automation.vault.query('workflows', {\n        'created_at': {'$gte': week_ago}\n    })\n\n    completed_this_week = len([w for w in recent_workflows if w.get('status') == 'completed'])\n    completion_rate = (completed_this_week / len(recent_workflows) * 100) if recent_workflows else 0\n\n    # Workflow types breakdown\n    workflow_types = {}\n    for workflow in recent_workflows:\n        wf_type = workflow['id'].split('_')[0]  # Extract type from ID\n        workflow_types[wf_type] = workflow_types.get(wf_type, 0) + 1\n\n    return {\n        'active_workflows': len(active_workflows),\n        'recent_failures': len(recent_failures),\n        'weekly_completion_rate': round(completion_rate, 2),\n        'total_workflows_this_week': len(recent_workflows),\n        'workflow_types': workflow_types,\n        'dashboard_updated_at': datetime.now().isoformat()\n    }\n</code></pre>"},{"location":"recipes/automation-agent/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Stateful Agent</p> <p>Build agents that learn and adapt from every interaction</p> </li> <li> <p> Multi-Provider Setup</p> <p>Optimize costs and capabilities across AI providers</p> </li> <li> <p> Back to Chatbot</p> <p>Build conversational interfaces for your workflows</p> </li> </ul> <p>You Built a Workflow Automation Engine!</p> <p>You've created an intelligent automation system that can handle complex, multi-step workflows with decision points, error handling, and state management. This goes far beyond simple automation tools like Zapier.</p> <p>Your automation agent now has: \u2705 Intelligent Decision Making - AI-driven workflow routing \u2705 State Management - Remembers progress across sessions \u2705 Error Handling - Retry logic and graceful failure handling \u2705 Performance Analytics - Track and optimize workflow efficiency \u2705 Parallel Execution - Handle multiple tasks simultaneously \u2705 Conditional Logic - Different paths based on data and context  </p>"},{"location":"recipes/chatbot/","title":"Recipe: Intelligent Chatbot","text":"<p>Build a Slack bot that remembers conversations, learns user preferences, and integrates with your existing tools.</p> <p>Perfect for Indie Hackers</p> <p>This recipe shows how to build a production-ready chatbot in under an hour. Deploy it to Slack, Discord, or any chat platform.</p>"},{"location":"recipes/chatbot/#what-youll-build","title":"What You'll Build","text":"<p>A chatbot that can:</p> <ul> <li>\ud83d\udcac Remember conversations across sessions</li> <li>\ud83d\udc64 Learn user preferences and adapt responses  </li> <li>\ud83d\udd27 Use custom tools to perform actions</li> <li>\ud83d\udcca Track usage and analytics automatically</li> <li>\ud83d\ude80 Scale to thousands of users without infrastructure work</li> </ul>"},{"location":"recipes/chatbot/#the-complete-code","title":"The Complete Code","text":"slack_bot.py<pre><code>from flowstack import Agent\nfrom datetime import datetime, timedelta\nimport json\n\n# Initialize the bot\nbot = Agent(\n    name=\"company-assistant\",\n    api_key=\"fs_your_api_key_here\",\n    system_prompt=\"\"\"You are a helpful company assistant bot. You can help users with:\n    - Checking their vacation days and time off\n    - Looking up company policies and information  \n    - Remembering their preferences for future conversations\n    - Helping with common HR and workplace questions\n\n    Always be friendly and professional. Use the available tools to provide accurate information.\"\"\"\n)\n\n# Tool 1: Vacation Day Management\n@bot.tool\ndef check_vacation_days(user_id: str) -&gt; dict:\n    \"\"\"Check how many vacation days a user has remaining\"\"\"\n    # In a real app, this would query your HR system\n    # For demo, we'll use DataVault to simulate user data\n\n    user_data = bot.vault.retrieve('employees', key=user_id) or {\n        'user_id': user_id,\n        'vacation_days_total': 20,\n        'vacation_days_used': 0,\n        'vacation_requests': []\n    }\n\n    remaining = user_data['vacation_days_total'] - user_data['vacation_days_used']\n\n    return {\n        'user_id': user_id,\n        'total_days': user_data['vacation_days_total'],\n        'used_days': user_data['vacation_days_used'],\n        'remaining_days': remaining,\n        'recent_requests': user_data['vacation_requests'][-3:]  # Last 3 requests\n    }\n\n@bot.tool\ndef request_vacation(user_id: str, start_date: str, end_date: str, reason: str = \"\") -&gt; dict:\n    \"\"\"Submit a vacation request\"\"\"\n    from datetime import datetime\n\n    # Get user data\n    user_data = bot.vault.retrieve('employees', key=user_id) or {\n        'user_id': user_id,\n        'vacation_days_total': 20,\n        'vacation_days_used': 0,\n        'vacation_requests': []\n    }\n\n    # Calculate days requested\n    start = datetime.fromisoformat(start_date)\n    end = datetime.fromisoformat(end_date)\n    days_requested = (end - start).days + 1\n\n    # Check if enough days available\n    remaining = user_data['vacation_days_total'] - user_data['vacation_days_used']\n    if days_requested &gt; remaining:\n        return {\n            'success': False,\n            'message': f'Not enough vacation days. You have {remaining} days remaining, but requested {days_requested} days.'\n        }\n\n    # Create request\n    request = {\n        'id': f\"req_{datetime.now().strftime('%Y%m%d_%H%M%S')}\",\n        'start_date': start_date,\n        'end_date': end_date,\n        'days': days_requested,\n        'reason': reason,\n        'status': 'pending',\n        'submitted_at': datetime.now().isoformat()\n    }\n\n    # Update user data\n    user_data['vacation_requests'].append(request)\n    user_data['vacation_days_used'] += days_requested  # Optimistically reserve\n\n    bot.vault.store('employees', user_data, key=user_id)\n\n    # Store the request for HR review\n    bot.vault.store('vacation_requests', request, key=request['id'])\n\n    return {\n        'success': True,\n        'message': f'Vacation request submitted for {days_requested} days from {start_date} to {end_date}',\n        'request_id': request['id'],\n        'remaining_days': user_data['vacation_days_total'] - user_data['vacation_days_used']\n    }\n\n# Tool 2: Company Knowledge Base\n@bot.tool\ndef search_company_policies(query: str) -&gt; dict:\n    \"\"\"Search company policies and information\"\"\"\n    # In a real app, this would search your knowledge base\n    # For demo, we'll create some sample policies\n\n    policies = [\n        {\n            'title': 'Remote Work Policy',\n            'content': 'Employees can work remotely up to 3 days per week with manager approval.',\n            'category': 'workplace',\n            'tags': ['remote', 'work from home', 'flexible']\n        },\n        {\n            'title': 'Vacation Policy', \n            'content': 'Full-time employees receive 20 vacation days per year. Part-time employees receive prorated vacation.',\n            'category': 'time-off',\n            'tags': ['vacation', 'time off', 'PTO']\n        },\n        {\n            'title': 'Equipment Policy',\n            'content': 'Company provides laptop and necessary equipment. Personal use is allowed within reason.',\n            'category': 'equipment',\n            'tags': ['laptop', 'equipment', 'IT']\n        },\n        {\n            'title': 'Health Benefits',\n            'content': 'Medical, dental, and vision coverage available. Company covers 80% of premiums.',\n            'category': 'benefits',\n            'tags': ['health', 'medical', 'benefits', 'insurance']\n        }\n    ]\n\n    # Simple text search\n    query_lower = query.lower()\n    matching_policies = []\n\n    for policy in policies:\n        if (query_lower in policy['title'].lower() or \n            query_lower in policy['content'].lower() or\n            any(query_lower in tag for tag in policy['tags'])):\n            matching_policies.append(policy)\n\n    return {\n        'query': query,\n        'matches': len(matching_policies),\n        'policies': matching_policies\n    }\n\n# Tool 3: User Preference Management\n@bot.tool\ndef remember_user_preference(user_id: str, preference_type: str, value: str) -&gt; dict:\n    \"\"\"Remember a user's preference for future conversations\"\"\"\n\n    # Get existing preferences\n    prefs = bot.vault.retrieve('user_preferences', key=user_id) or {\n        'user_id': user_id,\n        'preferences': {},\n        'updated_at': datetime.now().isoformat()\n    }\n\n    # Update preference\n    prefs['preferences'][preference_type] = value\n    prefs['updated_at'] = datetime.now().isoformat()\n\n    # Store back\n    bot.vault.store('user_preferences', prefs, key=user_id)\n\n    return {\n        'message': f\"I'll remember that you prefer {preference_type}: {value}\",\n        'user_id': user_id,\n        'preference_type': preference_type,\n        'value': value\n    }\n\n@bot.tool\ndef get_user_preferences(user_id: str) -&gt; dict:\n    \"\"\"Get a user's saved preferences\"\"\"\n\n    prefs = bot.vault.retrieve('user_preferences', key=user_id)\n\n    if not prefs:\n        return {\n            'user_id': user_id,\n            'preferences': {},\n            'message': 'No preferences saved yet'\n        }\n\n    return {\n        'user_id': user_id,\n        'preferences': prefs['preferences'],\n        'last_updated': prefs['updated_at']\n    }\n\n# Tool 4: Conversation History\n@bot.tool\ndef save_conversation_summary(user_id: str, summary: str, topics: list) -&gt; dict:\n    \"\"\"Save a summary of the conversation for future reference\"\"\"\n\n    conversation = {\n        'user_id': user_id,\n        'summary': summary,\n        'topics': topics,\n        'timestamp': datetime.now().isoformat(),\n        'date': datetime.now().date().isoformat()\n    }\n\n    # Store conversation\n    conv_key = bot.vault.store('conversations', conversation)\n\n    return {\n        'message': 'Conversation summary saved',\n        'conversation_id': conv_key,\n        'topics': topics\n    }\n\n@bot.tool\ndef recall_previous_conversations(user_id: str, days_back: int = 7) -&gt; dict:\n    \"\"\"Recall previous conversations with this user\"\"\"\n\n    cutoff_date = (datetime.now() - timedelta(days=days_back)).date().isoformat()\n\n    recent_conversations = bot.vault.query('conversations', {\n        'user_id': user_id,\n        'date': {'$gte': cutoff_date}\n    }, sort=[('timestamp', -1)], limit=5)\n\n    if not recent_conversations:\n        return {\n            'user_id': user_id,\n            'conversations': [],\n            'message': f'No conversations found in the last {days_back} days'\n        }\n\n    return {\n        'user_id': user_id,\n        'conversation_count': len(recent_conversations),\n        'conversations': recent_conversations,\n        'time_period': f'last {days_back} days'\n    }\n\n# Test the bot locally\ndef test_bot():\n    \"\"\"Test the bot with sample interactions\"\"\"\n    print(\"\ud83e\udd16 Testing Company Assistant Bot\")\n    print(\"=\" * 50)\n\n    # Test vacation day check\n    print(\"\\n1. Checking vacation days...\")\n    response = bot.chat(\"How many vacation days do I have left? My user ID is emp_123\")\n    print(f\"Bot: {response}\")\n\n    # Test preference setting\n    print(\"\\n2. Setting a preference...\")\n    response = bot.chat(\"Please remember that I prefer to be notified about meetings via email, not Slack. My user ID is emp_123\")\n    print(f\"Bot: {response}\")\n\n    # Test policy search\n    print(\"\\n3. Searching company policies...\")\n    response = bot.chat(\"What's our remote work policy?\")\n    print(f\"Bot: {response}\")\n\n    # Test vacation request\n    print(\"\\n4. Requesting vacation...\")\n    response = bot.chat(\"I'd like to request vacation from 2024-03-15 to 2024-03-18 for a family trip. My user ID is emp_123\")\n    print(f\"Bot: {response}\")\n\n    print(\"\\n\u2705 Local testing complete!\")\n\n# Deploy to production\ndef deploy_bot():\n    \"\"\"Deploy the bot to production\"\"\"\n    print(\"\\n\ud83d\ude80 Deploying to production...\")\n\n    endpoint = bot.deploy()\n\n    print(f\"\u2705 Bot deployed successfully!\")\n    print(f\"Webhook URL: {endpoint}/chat\")\n    print(f\"Health check: {endpoint}/health\")\n\n    print(\"\\n\ud83d\udcdd Next steps:\")\n    print(\"1. Add the webhook URL to your Slack app settings\")\n    print(\"2. Configure your chat platform to send messages to the endpoint\")\n    print(\"3. Test with real users!\")\n\n    return endpoint\n\nif __name__ == \"__main__\":\n    # Run local tests first\n    test_bot()\n\n    # Deploy if tests pass\n    deploy_choice = input(\"\\nDeploy to production? (y/N): \")\n    if deploy_choice.lower() == 'y':\n        deploy_bot()\n</code></pre>"},{"location":"recipes/chatbot/#integration-examples","title":"Integration Examples","text":""},{"location":"recipes/chatbot/#slack-integration","title":"Slack Integration","text":"<p>Once deployed, integrate with Slack:</p> slack_webhook.py<pre><code># This would be your Slack app's webhook handler\nimport requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\nFLOWSTACK_ENDPOINT = \"https://api.flowstack.fun/agents/company-assistant/chat\"\nFLOWSTACK_API_KEY = \"fs_your_api_key_here\"\n\n@app.route('/slack/events', methods=['POST'])\ndef handle_slack_event():\n    data = request.json\n\n    # Handle Slack challenge for webhook verification\n    if 'challenge' in data:\n        return jsonify({'challenge': data['challenge']})\n\n    # Process message events\n    if 'event' in data and data['event']['type'] == 'message':\n        event = data['event']\n\n        # Skip bot messages to avoid loops\n        if 'bot_id' in event:\n            return jsonify({'status': 'ignored'})\n\n        user_id = event['user']\n        text = event['text']\n        channel = event['channel']\n\n        # Send to FlowStack bot\n        response = requests.post(FLOWSTACK_ENDPOINT, \n            headers={\n                'Content-Type': 'application/json',\n                'X-API-Key': FLOWSTACK_API_KEY\n            },\n            json={\n                'message': f\"{text} (user_id: {user_id})\",\n                'context': {\n                    'platform': 'slack',\n                    'channel': channel,\n                    'user': user_id\n                }\n            }\n        )\n\n        if response.status_code == 200:\n            bot_reply = response.json()['message']\n\n            # Send reply back to Slack\n            # (You'd use Slack's Web API here)\n            send_slack_message(channel, bot_reply)\n\n    return jsonify({'status': 'ok'})\n\ndef send_slack_message(channel, text):\n    \"\"\"Send message back to Slack channel\"\"\"\n    # Implementation depends on your Slack app setup\n    pass\n\nif __name__ == '__main__':\n    app.run(port=3000)\n</code></pre>"},{"location":"recipes/chatbot/#discord-integration","title":"Discord Integration","text":"discord_bot.py<pre><code>import discord\nimport requests\nimport asyncio\n\nFLOWSTACK_ENDPOINT = \"https://api.flowstack.fun/agents/company-assistant/chat\"\nFLOWSTACK_API_KEY = \"fs_your_api_key_here\"\n\nclass FlowStackBot(discord.Client):\n    async def on_ready(self):\n        print(f'Logged in as {self.user}')\n\n    async def on_message(self, message):\n        # Don't respond to ourselves\n        if message.author == self.user:\n            return\n\n        # Only respond to direct messages or mentions\n        if not (isinstance(message.channel, discord.DMChannel) or \n                self.user.mentioned_in(message)):\n            return\n\n        # Clean the message\n        content = message.content.replace(f'&lt;@{self.user.id}&gt;', '').strip()\n\n        # Send to FlowStack\n        try:\n            response = requests.post(FLOWSTACK_ENDPOINT,\n                headers={\n                    'Content-Type': 'application/json',\n                    'X-API-Key': FLOWSTACK_API_KEY\n                },\n                json={\n                    'message': f\"{content} (user_id: {message.author.id})\",\n                    'context': {\n                        'platform': 'discord',\n                        'guild': str(message.guild.id) if message.guild else None,\n                        'channel': str(message.channel.id),\n                        'user': str(message.author.id)\n                    }\n                }\n            )\n\n            if response.status_code == 200:\n                bot_reply = response.json()['message']\n                await message.reply(bot_reply)\n            else:\n                await message.reply(\"Sorry, I'm having trouble right now. Please try again later.\")\n\n        except Exception as e:\n            print(f\"Error: {e}\")\n            await message.reply(\"Oops! Something went wrong.\")\n\n# Run the Discord bot\nclient = FlowStackBot()\nclient.run('YOUR_DISCORD_BOT_TOKEN')\n</code></pre>"},{"location":"recipes/chatbot/#advanced-features","title":"Advanced Features","text":""},{"location":"recipes/chatbot/#analytics-dashboard","title":"Analytics Dashboard","text":"<p>Add usage tracking to understand how your bot is being used:</p> <pre><code>@bot.tool\ndef track_bot_usage(user_id: str, action: str, details: dict = None) -&gt; dict:\n    \"\"\"Track bot usage for analytics\"\"\"\n\n    usage_event = {\n        'user_id': user_id,\n        'action': action,\n        'details': details or {},\n        'timestamp': datetime.now().isoformat(),\n        'date': datetime.now().date().isoformat(),\n        'hour': datetime.now().hour\n    }\n\n    bot.vault.store('usage_analytics', usage_event)\n\n    return {'tracked': True, 'action': action}\n\n@bot.tool\ndef get_bot_analytics(days: int = 7) -&gt; dict:\n    \"\"\"Get bot usage analytics\"\"\"\n\n    cutoff_date = (datetime.now() - timedelta(days=days)).date().isoformat()\n\n    events = bot.vault.query('usage_analytics', {\n        'date': {'$gte': cutoff_date}\n    })\n\n    # Analyze usage patterns\n    total_events = len(events)\n    unique_users = len(set(event['user_id'] for event in events))\n\n    # Most common actions\n    action_counts = {}\n    for event in events:\n        action = event['action']\n        action_counts[action] = action_counts.get(action, 0) + 1\n\n    # Peak usage hours\n    hour_counts = {}\n    for event in events:\n        hour = event['hour']\n        hour_counts[hour] = hour_counts.get(hour, 0) + 1\n\n    return {\n        'period_days': days,\n        'total_interactions': total_events,\n        'unique_users': unique_users,\n        'top_actions': sorted(action_counts.items(), key=lambda x: x[1], reverse=True)[:5],\n        'peak_hours': sorted(hour_counts.items(), key=lambda x: x[1], reverse=True)[:3]\n    }\n</code></pre>"},{"location":"recipes/chatbot/#smart-suggestions","title":"Smart Suggestions","text":"<p>Make your bot proactive by suggesting actions:</p> <pre><code>@bot.tool\ndef suggest_next_actions(user_id: str) -&gt; dict:\n    \"\"\"Suggest relevant actions based on user history\"\"\"\n\n    # Get user's recent activity\n    recent_conversations = bot.vault.query('conversations', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=5)\n\n    # Get user preferences\n    prefs = bot.vault.retrieve('user_preferences', key=user_id)\n\n    suggestions = []\n\n    # Check if they haven't checked vacation days recently\n    vacation_checks = [conv for conv in recent_conversations \n                      if 'vacation' in conv.get('summary', '').lower()]\n\n    if not vacation_checks:\n        suggestions.append({\n            'action': 'check_vacation_days',\n            'text': \"Check your remaining vacation days\",\n            'reason': \"You haven't checked lately\"\n        })\n\n    # Suggest based on preferences\n    if prefs and 'communication_style' not in prefs.get('preferences', {}):\n        suggestions.append({\n            'action': 'set_communication_preference',\n            'text': \"Set your communication preferences\",\n            'reason': \"This helps me tailor responses to your style\"\n        })\n\n    return {\n        'user_id': user_id,\n        'suggestions': suggestions,\n        'suggestion_count': len(suggestions)\n    }\n</code></pre>"},{"location":"recipes/chatbot/#deployment-checklist","title":"Deployment Checklist","text":"<p>Before going live with your chatbot:</p> <ul> <li> Test all tools with various inputs</li> <li> Set up error handling for external API failures</li> <li> Configure rate limiting in your chat platform</li> <li> Add logging for debugging production issues</li> <li> Set up monitoring for usage patterns</li> <li> Create user onboarding flow</li> <li> Document bot capabilities for users</li> <li> Plan for scaling as user base grows</li> </ul>"},{"location":"recipes/chatbot/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Automation Agent</p> <p>Build workflow automation that's more powerful than Zapier</p> </li> <li> <p> Stateful Agent</p> <p>Create agents that learn and remember across sessions</p> </li> <li> <p> Multi-Provider Setup</p> <p>Switch between AI providers to optimize costs and capabilities</p> </li> </ul> <p>You Built a Production Chatbot!</p> <p>In under an hour, you've created a chatbot that can handle real users, remember conversations, and integrate with existing systems. The bot automatically scales from 1 to 1000s of users without any infrastructure work from you.</p> <p>Your chatbot now has: \u2705 Memory - Remembers users and conversations \u2705 Tools - Can perform real actions \u2705 Integration - Works with Slack, Discord, etc. \u2705 Analytics - Tracks usage patterns \u2705 Scaling - Handles growth automatically  </p>"},{"location":"recipes/multi-provider/","title":"Recipe: Multi-Provider Setup","text":"<p>Switch between AI providers to optimize costs, capabilities, and performance for different use cases.</p> <p>Perfect for Cost Optimization</p> <p>This recipe shows how to use different AI providers strategically - managed Bedrock for reliability, your own OpenAI for cost control, and Anthropic for specific capabilities.</p>"},{"location":"recipes/multi-provider/#what-youll-build","title":"What You'll Build","text":"<p>A smart agent that can:</p> <ul> <li>\ud83d\udd04 Switch providers dynamically based on task requirements</li> <li>\ud83d\udcb0 Optimize costs by using the right provider for each job</li> <li>\ud83d\ude80 Maximize capabilities by leveraging each provider's strengths</li> <li>\ud83d\udcca Track usage and costs across all providers</li> <li>\ud83d\udd27 Handle provider failures with automatic fallbacks</li> <li>\u2696\ufe0f Load balance across multiple providers</li> </ul>"},{"location":"recipes/multi-provider/#the-complete-code","title":"The Complete Code","text":"multi_provider_agent.py<pre><code>from flowstack import Agent, Models, Providers\nfrom datetime import datetime, timedelta\nimport json\n\n# Initialize the multi-provider agent with default provider\nagent = Agent(\n    name=\"smart-multi-provider\",\n    api_key=\"fs_your_api_key_here\",\n    provider=Providers.BEDROCK,  # Default to managed Bedrock\n    model=Models.CLAUDE_35_SONNET,\n    system_prompt=\"\"\"You are a smart assistant that can use multiple AI providers optimally. \n    You should:\n    - Choose the best provider for each task based on requirements\n    - Consider cost, speed, and capability trade-offs\n    - Track usage across providers for optimization\n    - Handle provider failures gracefully with fallbacks\n    \"\"\"\n)\n\n# Define provider configurations\nPROVIDER_CONFIGS = {\n    'bedrock_managed': {\n        'provider': Providers.BEDROCK,\n        'model': Models.CLAUDE_35_SONNET,\n        'byok': None,  # Managed by FlowStack\n        'cost_per_session': 'managed',  # Included in FlowStack pricing\n        'strengths': ['reliability', 'no_setup', 'managed_billing'],\n        'best_for': ['production', 'customer_facing', 'critical_tasks']\n    },\n    'openai_byok': {\n        'provider': Providers.OPENAI,\n        'model': 'gpt-4o',\n        'byok': {'api_key': 'sk-your-openai-key'},  # Your own key\n        'cost_per_session': 'variable',  # Direct OpenAI billing\n        'strengths': ['cost_control', 'latest_models', 'function_calling'],\n        'best_for': ['development', 'high_volume', 'cost_optimization']\n    },\n    'anthropic_byok': {\n        'provider': Providers.ANTHROPIC,\n        'model': 'claude-3-opus-20240229',\n        'byok': {'api_key': 'sk-ant-your-anthropic-key'},\n        'cost_per_session': 'variable',\n        'strengths': ['reasoning', 'safety', 'long_context'],\n        'best_for': ['complex_analysis', 'research', 'content_generation']\n    },\n    'openai_fast': {\n        'provider': Providers.OPENAI,\n        'model': 'gpt-3.5-turbo',\n        'byok': {'api_key': 'sk-your-openai-key'},\n        'cost_per_session': 'low',\n        'strengths': ['speed', 'low_cost', 'good_performance'],\n        'best_for': ['simple_tasks', 'high_frequency', 'testing']\n    }\n}\n\n# Tool 1: Smart Provider Selection\n@agent.tool\ndef select_optimal_provider(task_description: str, requirements: dict = None) -&gt; dict:\n    \"\"\"Intelligently select the best provider for a given task\"\"\"\n\n    requirements = requirements or {}\n\n    # Analyze task requirements\n    task_analysis = analyze_task_requirements(task_description, requirements)\n\n    # Score each provider for this task\n    provider_scores = {}\n    for provider_name, config in PROVIDER_CONFIGS.items():\n        score = calculate_provider_score(task_analysis, config)\n        provider_scores[provider_name] = score\n\n    # Select best provider\n    best_provider = max(provider_scores.items(), key=lambda x: x[1])\n    selected_config = PROVIDER_CONFIGS[best_provider[0]]\n\n    # Switch to selected provider\n    switch_result = switch_provider(best_provider[0])\n\n    return {\n        'task_description': task_description,\n        'selected_provider': best_provider[0],\n        'provider_config': selected_config,\n        'selection_score': best_provider[1],\n        'all_scores': provider_scores,\n        'task_analysis': task_analysis,\n        'switch_successful': switch_result['success']\n    }\n\ndef analyze_task_requirements(task_description: str, requirements: dict) -&gt; dict:\n    \"\"\"Analyze task to determine requirements\"\"\"\n\n    task_lower = task_description.lower()\n    analysis = {\n        'complexity': 'medium',\n        'speed_priority': 'medium',\n        'cost_priority': 'medium',\n        'reliability_priority': 'high',\n        'task_type': 'general'\n    }\n\n    # Complexity analysis\n    complex_indicators = ['analyze', 'research', 'complex', 'detailed', 'comprehensive']\n    simple_indicators = ['simple', 'quick', 'basic', 'summarize']\n\n    if any(indicator in task_lower for indicator in complex_indicators):\n        analysis['complexity'] = 'high'\n    elif any(indicator in task_lower for indicator in simple_indicators):\n        analysis['complexity'] = 'low'\n\n    # Speed priority analysis\n    if any(word in task_lower for word in ['urgent', 'quick', 'fast', 'immediate']):\n        analysis['speed_priority'] = 'high'\n    elif any(word in task_lower for word in ['detailed', 'thorough', 'comprehensive']):\n        analysis['speed_priority'] = 'low'\n\n    # Cost priority from requirements\n    if requirements.get('cost_sensitive', False):\n        analysis['cost_priority'] = 'high'\n    elif requirements.get('premium_quality', False):\n        analysis['cost_priority'] = 'low'\n\n    # Task type classification\n    if any(word in task_lower for word in ['code', 'programming', 'function']):\n        analysis['task_type'] = 'coding'\n    elif any(word in task_lower for word in ['write', 'content', 'article', 'blog']):\n        analysis['task_type'] = 'content_creation'\n    elif any(word in task_lower for word in ['analyze', 'research', 'study']):\n        analysis['task_type'] = 'analysis'\n    elif any(word in task_lower for word in ['chat', 'conversation', 'help']):\n        analysis['task_type'] = 'conversation'\n\n    return analysis\n\ndef calculate_provider_score(task_analysis: dict, provider_config: dict) -&gt; float:\n    \"\"\"Calculate how well a provider matches task requirements\"\"\"\n\n    score = 0.0\n\n    # Base score for all providers\n    score += 50\n\n    # Complexity matching\n    if task_analysis['complexity'] == 'high':\n        if 'reasoning' in provider_config['strengths']:\n            score += 20\n        if provider_config['model'] in ['claude-3-opus-20240229', 'gpt-4o']:\n            score += 15\n    elif task_analysis['complexity'] == 'low':\n        if 'speed' in provider_config['strengths']:\n            score += 15\n        if provider_config['model'] == 'gpt-3.5-turbo':\n            score += 10\n\n    # Cost considerations\n    if task_analysis['cost_priority'] == 'high':\n        if provider_config['cost_per_session'] == 'low':\n            score += 20\n        elif provider_config['cost_per_session'] == 'variable':\n            score += 10\n        elif provider_config['cost_per_session'] == 'managed':\n            score -= 5\n\n    # Speed considerations\n    if task_analysis['speed_priority'] == 'high':\n        if 'speed' in provider_config['strengths']:\n            score += 15\n        if provider_config['model'] == 'gpt-3.5-turbo':\n            score += 10\n\n    # Reliability considerations\n    if task_analysis['reliability_priority'] == 'high':\n        if 'reliability' in provider_config['strengths']:\n            score += 15\n        if provider_config['provider'] == Providers.BEDROCK:\n            score += 10\n\n    # Task type specific bonuses\n    task_type = task_analysis['task_type']\n    if task_type == 'coding' and 'function_calling' in provider_config['strengths']:\n        score += 15\n    elif task_type == 'content_creation' and 'long_context' in provider_config['strengths']:\n        score += 15\n    elif task_type == 'analysis' and 'reasoning' in provider_config['strengths']:\n        score += 15\n\n    return score\n\n@agent.tool\ndef switch_provider(provider_name: str) -&gt; dict:\n    \"\"\"Switch to a different provider configuration\"\"\"\n\n    if provider_name not in PROVIDER_CONFIGS:\n        return {\n            'success': False,\n            'error': f'Unknown provider configuration: {provider_name}',\n            'available_providers': list(PROVIDER_CONFIGS.keys())\n        }\n\n    config = PROVIDER_CONFIGS[provider_name]\n\n    try:\n        # Switch the agent to the new provider\n        agent.set_provider(\n            provider=config['provider'],\n            byok=config['byok']\n        )\n        agent.set_model(config['model'])\n\n        # Log the switch\n        switch_log = {\n            'switched_to': provider_name,\n            'provider': config['provider'],\n            'model': config['model'],\n            'timestamp': datetime.now().isoformat(),\n            'has_byok': config['byok'] is not None\n        }\n\n        agent.vault.store('provider_switches', switch_log)\n\n        return {\n            'success': True,\n            'switched_to': provider_name,\n            'provider': config['provider'],\n            'model': config['model'],\n            'strengths': config['strengths'],\n            'cost_model': config['cost_per_session']\n        }\n\n    except Exception as e:\n        return {\n            'success': False,\n            'error': str(e),\n            'attempted_provider': provider_name\n        }\n\n# Tool 2: Cost Tracking and Optimization\n@agent.tool\ndef track_provider_usage(provider_name: str, task_description: str, session_cost: float = None) -&gt; dict:\n    \"\"\"Track usage and costs across providers\"\"\"\n\n    usage_record = {\n        'provider_name': provider_name,\n        'provider': PROVIDER_CONFIGS[provider_name]['provider'],\n        'model': PROVIDER_CONFIGS[provider_name]['model'],\n        'task_description': task_description,\n        'session_cost': session_cost,\n        'timestamp': datetime.now().isoformat(),\n        'date': datetime.now().date().isoformat()\n    }\n\n    agent.vault.store('provider_usage', usage_record)\n\n    # Calculate daily and monthly usage\n    today = datetime.now().date().isoformat()\n    month_start = datetime.now().replace(day=1).date().isoformat()\n\n    daily_usage = agent.vault.query('provider_usage', {\n        'date': today,\n        'provider_name': provider_name\n    })\n\n    monthly_usage = agent.vault.query('provider_usage', {\n        'date': {'$gte': month_start},\n        'provider_name': provider_name\n    })\n\n    return {\n        'recorded': True,\n        'provider_name': provider_name,\n        'task_description': task_description,\n        'daily_sessions': len(daily_usage),\n        'monthly_sessions': len(monthly_usage),\n        'estimated_monthly_cost': estimate_monthly_cost(monthly_usage, provider_name)\n    }\n\ndef estimate_monthly_cost(usage_records: list, provider_name: str) -&gt; dict:\n    \"\"\"Estimate monthly cost for a provider\"\"\"\n\n    config = PROVIDER_CONFIGS[provider_name]\n\n    if config['cost_per_session'] == 'managed':\n        # Managed pricing - included in FlowStack subscription\n        return {\n            'type': 'managed',\n            'sessions': len(usage_records),\n            'estimated_cost': 'included_in_subscription',\n            'note': 'Covered by FlowStack session pricing'\n        }\n\n    elif config['cost_per_session'] == 'low':\n        # Estimate for GPT-3.5-turbo or similar\n        estimated_cost = len(usage_records) * 0.05  # $0.05 per session estimate\n        return {\n            'type': 'byok_low_cost',\n            'sessions': len(usage_records),\n            'estimated_cost': round(estimated_cost, 2),\n            'cost_per_session': 0.05\n        }\n\n    elif config['cost_per_session'] == 'variable':\n        # Higher-end models - estimate based on model\n        if 'gpt-4' in config['model']:\n            cost_per_session = 0.25\n        elif 'claude-3-opus' in config['model']:\n            cost_per_session = 0.30\n        else:\n            cost_per_session = 0.15\n\n        estimated_cost = len(usage_records) * cost_per_session\n        return {\n            'type': 'byok_variable',\n            'sessions': len(usage_records),\n            'estimated_cost': round(estimated_cost, 2),\n            'cost_per_session': cost_per_session\n        }\n\n    return {\n        'type': 'unknown',\n        'sessions': len(usage_records),\n        'estimated_cost': 'unable_to_estimate'\n    }\n\n@agent.tool\ndef get_cost_optimization_recommendations() -&gt; dict:\n    \"\"\"Analyze usage patterns and recommend cost optimizations\"\"\"\n\n    # Get usage from last 30 days\n    thirty_days_ago = (datetime.now() - timedelta(days=30)).date().isoformat()\n\n    all_usage = agent.vault.query('provider_usage', {\n        'date': {'$gte': thirty_days_ago}\n    })\n\n    if not all_usage:\n        return {\n            'message': 'No usage data available for optimization analysis',\n            'recommendations': []\n        }\n\n    # Analyze usage by provider\n    provider_usage = {}\n    for record in all_usage:\n        provider = record['provider_name']\n        if provider not in provider_usage:\n            provider_usage[provider] = []\n        provider_usage[provider].append(record)\n\n    recommendations = []\n\n    # Check for high-cost provider overuse\n    for provider_name, usage_records in provider_usage.items():\n        config = PROVIDER_CONFIGS[provider_name]\n\n        if len(usage_records) &gt; 100 and config['cost_per_session'] == 'variable':\n            # High usage of expensive provider\n            recommendations.append({\n                'type': 'cost_reduction',\n                'priority': 'high',\n                'message': f'High usage of {provider_name} ({len(usage_records)} sessions). Consider using cheaper alternatives for simple tasks.',\n                'suggestion': 'Use gpt-3.5-turbo for simple tasks, reserve expensive models for complex work',\n                'potential_savings': estimate_potential_savings(usage_records, provider_name)\n            })\n\n        if config['cost_per_session'] == 'managed' and len(usage_records) &lt; 10:\n            # Low usage of managed provider\n            recommendations.append({\n                'type': 'efficiency',\n                'priority': 'medium',\n                'message': f'Low usage of managed {provider_name} ({len(usage_records)} sessions). You\\'re paying for FlowStack sessions anyway.',\n                'suggestion': 'Consider using managed Bedrock more for reliability and simplicity'\n            })\n\n    # Check for task-provider mismatches\n    task_analysis = analyze_task_provider_matching(all_usage)\n    if task_analysis['mismatches']:\n        recommendations.append({\n            'type': 'optimization',\n            'priority': 'medium',\n            'message': 'Some tasks may be using suboptimal providers',\n            'mismatches': task_analysis['mismatches'][:3],  # Top 3 mismatches\n            'suggestion': 'Use automatic provider selection for better optimization'\n        })\n\n    return {\n        'analysis_period_days': 30,\n        'total_sessions': len(all_usage),\n        'providers_used': list(provider_usage.keys()),\n        'recommendations': recommendations,\n        'monthly_cost_estimate': calculate_total_monthly_cost(provider_usage)\n    }\n\ndef estimate_potential_savings(usage_records: list, current_provider: str) -&gt; dict:\n    \"\"\"Estimate potential savings by switching providers for some tasks\"\"\"\n\n    # Simulate switching 50% of simple tasks to cheaper provider\n    simple_tasks = 0\n    for record in usage_records:\n        task = record.get('task_description', '').lower()\n        if any(word in task for word in ['simple', 'quick', 'basic', 'summarize']):\n            simple_tasks += 1\n\n    switchable_sessions = simple_tasks // 2  # Conservative estimate\n\n    current_config = PROVIDER_CONFIGS[current_provider]\n    if current_config['cost_per_session'] == 'variable':\n        current_cost_per_session = 0.25 if 'gpt-4' in current_config['model'] else 0.15\n        cheap_cost_per_session = 0.05  # GPT-3.5-turbo estimate\n\n        monthly_savings = switchable_sessions * (current_cost_per_session - cheap_cost_per_session)\n\n        return {\n            'switchable_sessions': switchable_sessions,\n            'monthly_savings': round(monthly_savings, 2),\n            'annual_savings': round(monthly_savings * 12, 2)\n        }\n\n    return {'monthly_savings': 0, 'reason': 'already_using_managed_or_cheap_provider'}\n\ndef analyze_task_provider_matching(usage_records: list) -&gt; dict:\n    \"\"\"Analyze if tasks are using optimal providers\"\"\"\n\n    mismatches = []\n\n    for record in usage_records:\n        task = record.get('task_description', '')\n        provider_name = record['provider_name']\n\n        # Analyze what would be optimal for this task\n        task_analysis = analyze_task_requirements(task, {})\n        optimal_provider = None\n        best_score = 0\n\n        for p_name, config in PROVIDER_CONFIGS.items():\n            score = calculate_provider_score(task_analysis, config)\n            if score &gt; best_score:\n                best_score = score\n                optimal_provider = p_name\n\n        # Check if current provider is significantly suboptimal\n        current_score = calculate_provider_score(task_analysis, PROVIDER_CONFIGS[provider_name])\n\n        if optimal_provider != provider_name and (best_score - current_score) &gt; 15:\n            mismatches.append({\n                'task': task[:100],  # Truncate long tasks\n                'current_provider': provider_name,\n                'optimal_provider': optimal_provider,\n                'score_difference': round(best_score - current_score, 1)\n            })\n\n    return {\n        'total_tasks_analyzed': len(usage_records),\n        'mismatches_found': len(mismatches),\n        'mismatches': sorted(mismatches, key=lambda x: x['score_difference'], reverse=True)\n    }\n\n# Tool 3: Provider Health and Fallback\n@agent.tool\ndef check_provider_health() -&gt; dict:\n    \"\"\"Check health of all configured providers\"\"\"\n\n    health_status = {}\n\n    for provider_name, config in PROVIDER_CONFIGS.items():\n        try:\n            # Temporarily switch to provider and test\n            original_provider = agent.provider\n            original_model = agent.model\n\n            agent.set_provider(config['provider'], config['byok'])\n            agent.set_model(config['model'])\n\n            # Quick health check\n            start_time = datetime.now()\n            test_response = agent.chat(\"Test message - please respond with 'OK'\")\n            response_time = (datetime.now() - start_time).total_seconds()\n\n            health_status[provider_name] = {\n                'status': 'healthy',\n                'response_time_seconds': round(response_time, 2),\n                'test_successful': 'OK' in test_response or 'ok' in test_response.lower(),\n                'last_checked': datetime.now().isoformat()\n            }\n\n            # Restore original provider\n            agent.set_provider(original_provider)\n            agent.set_model(original_model)\n\n        except Exception as e:\n            health_status[provider_name] = {\n                'status': 'unhealthy',\n                'error': str(e),\n                'last_checked': datetime.now().isoformat()\n            }\n\n    # Store health check results\n    health_record = {\n        'timestamp': datetime.now().isoformat(),\n        'provider_health': health_status,\n        'healthy_providers': [p for p, status in health_status.items() if status['status'] == 'healthy'],\n        'unhealthy_providers': [p for p, status in health_status.items() if status['status'] == 'unhealthy']\n    }\n\n    agent.vault.store('provider_health_checks', health_record)\n\n    return health_record\n\n@agent.tool\ndef execute_with_fallback(task: str, preferred_provider: str = None, max_retries: int = 3) -&gt; dict:\n    \"\"\"Execute a task with automatic provider fallback on failure\"\"\"\n\n    # Determine provider order\n    if preferred_provider and preferred_provider in PROVIDER_CONFIGS:\n        provider_order = [preferred_provider]\n        # Add other providers as fallbacks\n        provider_order.extend([p for p in PROVIDER_CONFIGS.keys() if p != preferred_provider])\n    else:\n        # Use all providers in order of reliability\n        provider_order = ['bedrock_managed', 'openai_byok', 'anthropic_byok', 'openai_fast']\n\n    attempts = []\n\n    for attempt, provider_name in enumerate(provider_order):\n        if attempt &gt;= max_retries:\n            break\n\n        try:\n            # Switch to provider\n            switch_result = switch_provider(provider_name)\n\n            if not switch_result['success']:\n                attempts.append({\n                    'provider': provider_name,\n                    'attempt': attempt + 1,\n                    'result': 'failed_to_switch',\n                    'error': switch_result.get('error')\n                })\n                continue\n\n            # Execute task\n            start_time = datetime.now()\n            response = agent.chat(task)\n            execution_time = (datetime.now() - start_time).total_seconds()\n\n            # Success!\n            attempts.append({\n                'provider': provider_name,\n                'attempt': attempt + 1,\n                'result': 'success',\n                'execution_time_seconds': round(execution_time, 2)\n            })\n\n            # Track successful usage\n            track_provider_usage(provider_name, task)\n\n            return {\n                'success': True,\n                'response': response,\n                'provider_used': provider_name,\n                'attempts': attempts,\n                'total_attempts': len(attempts)\n            }\n\n        except Exception as e:\n            attempts.append({\n                'provider': provider_name,\n                'attempt': attempt + 1,\n                'result': 'failed',\n                'error': str(e)\n            })\n            continue\n\n    # All providers failed\n    return {\n        'success': False,\n        'error': 'All providers failed',\n        'attempts': attempts,\n        'total_attempts': len(attempts)\n    }\n\n# Tool 4: Load Balancing\n@agent.tool\ndef distribute_load_across_providers(tasks: list, strategy: str = 'round_robin') -&gt; dict:\n    \"\"\"Distribute multiple tasks across providers for load balancing\"\"\"\n\n    if strategy == 'round_robin':\n        # Simple round-robin distribution\n        provider_names = list(PROVIDER_CONFIGS.keys())\n        task_assignments = []\n\n        for i, task in enumerate(tasks):\n            provider = provider_names[i % len(provider_names)]\n            task_assignments.append({\n                'task_id': i,\n                'task': task,\n                'assigned_provider': provider\n            })\n\n    elif strategy == 'optimal':\n        # Assign each task to its optimal provider\n        task_assignments = []\n\n        for i, task in enumerate(tasks):\n            optimal_result = select_optimal_provider(task)\n            task_assignments.append({\n                'task_id': i,\n                'task': task,\n                'assigned_provider': optimal_result['selected_provider'],\n                'selection_score': optimal_result['selection_score']\n            })\n\n    elif strategy == 'cost_optimized':\n        # Prioritize cheaper providers\n        cheap_providers = [p for p, config in PROVIDER_CONFIGS.items() \n                          if config['cost_per_session'] in ['low', 'managed']]\n        expensive_providers = [p for p, config in PROVIDER_CONFIGS.items() \n                              if config['cost_per_session'] == 'variable']\n\n        task_assignments = []\n\n        for i, task in enumerate(tasks):\n            # Use cheap providers for simple tasks, expensive for complex\n            task_analysis = analyze_task_requirements(task, {})\n\n            if task_analysis['complexity'] == 'low':\n                provider = cheap_providers[i % len(cheap_providers)]\n            else:\n                provider = expensive_providers[i % len(expensive_providers)]\n\n            task_assignments.append({\n                'task_id': i,\n                'task': task,\n                'assigned_provider': provider,\n                'reason': f\"task_complexity_{task_analysis['complexity']}\"\n            })\n\n    return {\n        'strategy': strategy,\n        'total_tasks': len(tasks),\n        'task_assignments': task_assignments,\n        'provider_distribution': calculate_provider_distribution(task_assignments)\n    }\n\ndef calculate_provider_distribution(task_assignments: list) -&gt; dict:\n    \"\"\"Calculate how tasks are distributed across providers\"\"\"\n\n    distribution = {}\n    for assignment in task_assignments:\n        provider = assignment['assigned_provider']\n        distribution[provider] = distribution.get(provider, 0) + 1\n\n    return distribution\n\n# Test the multi-provider agent\ndef test_multi_provider():\n    \"\"\"Test the multi-provider agent with different scenarios\"\"\"\n    print(\"\ud83d\udd04 Testing Multi-Provider Agent\")\n    print(\"=\" * 50)\n\n    # Test 1: Provider selection for different task types\n    print(\"\\n1. Testing smart provider selection...\")\n\n    test_tasks = [\n        \"Write a simple summary of this text\",\n        \"Analyze the complex implications of quantum computing on cryptography\",\n        \"Quick help with basic Python syntax\",\n        \"Detailed research report on climate change impacts\"\n    ]\n\n    for task in test_tasks:\n        response = agent.chat(f\"Select optimal provider for: {task}\")\n        print(f\"Task: {task[:50]}...\")\n        print(f\"Selection: {response}\")\n        print()\n\n    # Test 2: Cost tracking\n    print(\"\\n2. Testing cost tracking...\")\n    response = agent.chat(\"Track usage for openai_fast provider for the task: basic math calculation\")\n    print(f\"Cost Tracking: {response}\")\n\n    # Test 3: Health check\n    print(\"\\n3. Testing provider health...\")\n    response = agent.chat(\"Check the health of all providers\")\n    print(f\"Health Check: {response}\")\n\n    # Test 4: Fallback execution\n    print(\"\\n4. Testing fallback execution...\")\n    response = agent.chat(\"Execute with fallback: What is 2+2? (prefer anthropic_byok)\")\n    print(f\"Fallback Execution: {response}\")\n\n    print(\"\\n\u2705 Multi-provider testing complete!\")\n\n# Deploy the multi-provider agent\ndef deploy_multi_provider():\n    \"\"\"Deploy the multi-provider agent to production\"\"\"\n    print(\"\\n\ud83d\ude80 Deploying multi-provider agent...\")\n\n    endpoint = agent.deploy()\n\n    print(f\"\u2705 Multi-provider agent deployed!\")\n    print(f\"Endpoint: {endpoint}\")\n\n    print(\"\\n\ud83d\udd04 Your agent now supports:\")\n    print(\"\u2022 Automatic provider selection based on task requirements\")\n    print(\"\u2022 Cost tracking and optimization recommendations\")\n    print(\"\u2022 Provider health monitoring and fallback\")\n    print(\"\u2022 Load balancing across multiple providers\")\n    print(\"\u2022 Real-time provider switching\")\n\n    return endpoint\n\nif __name__ == \"__main__\":\n    # Run tests\n    test_multi_provider()\n\n    # Deploy\n    deploy_choice = input(\"\\nDeploy multi-provider agent? (y/N): \")\n    if deploy_choice.lower() == 'y':\n        deploy_multi_provider()\n</code></pre>"},{"location":"recipes/multi-provider/#provider-strategy-examples","title":"Provider Strategy Examples","text":""},{"location":"recipes/multi-provider/#cost-optimized-setup","title":"Cost-Optimized Setup","text":"cost_optimized_config.py<pre><code># Configuration optimized for minimal costs\nCOST_OPTIMIZED_CONFIGS = {\n    'ultra_cheap': {\n        'provider': Providers.OPENAI,\n        'model': 'gpt-3.5-turbo',\n        'byok': {'api_key': 'sk-your-openai-key'},\n        'use_for': ['simple_tasks', 'high_volume', 'testing']\n    },\n    'balanced': {\n        'provider': Providers.BEDROCK,\n        'model': Models.CLAUDE_35_HAIKU,  # Fastest/cheapest Claude\n        'byok': None,  # Managed\n        'use_for': ['production', 'customer_facing']\n    },\n    'premium_only_when_needed': {\n        'provider': Providers.ANTHROPIC,\n        'model': 'claude-3-opus-20240229',\n        'byok': {'api_key': 'sk-ant-your-key'},\n        'use_for': ['complex_analysis', 'critical_decisions']\n    }\n}\n\ndef setup_cost_optimized_agent():\n    \"\"\"Setup agent with cost optimization as primary goal\"\"\"\n\n    agent = Agent(\n        name=\"cost-optimized-assistant\",\n        api_key=\"fs_your_api_key\",\n        provider=Providers.OPENAI,  # Start with cheapest\n        model=\"gpt-3.5-turbo\",\n        byok={'api_key': 'sk-your-openai-key'}\n    )\n\n    @agent.tool\n    def smart_cost_routing(task: str, max_cost_per_session: float = 0.10):\n        \"\"\"Route tasks based on cost constraints\"\"\"\n\n        # Estimate task complexity\n        complexity = estimate_task_complexity(task)\n\n        if complexity == 'simple' and max_cost_per_session &gt;= 0.05:\n            return switch_to_provider('ultra_cheap')\n        elif complexity == 'medium' and max_cost_per_session &gt;= 0.15:\n            return switch_to_provider('balanced')\n        elif complexity == 'complex' and max_cost_per_session &gt;= 0.30:\n            return switch_to_provider('premium_only_when_needed')\n        else:\n            return {'error': 'Task too expensive for budget', 'max_budget': max_cost_per_session}\n\n    return agent\n</code></pre>"},{"location":"recipes/multi-provider/#performance-optimized-setup","title":"Performance-Optimized Setup","text":"performance_optimized_config.py<pre><code># Configuration optimized for speed and reliability\nPERFORMANCE_CONFIGS = {\n    'ultra_fast': {\n        'provider': Providers.OPENAI,\n        'model': 'gpt-3.5-turbo',\n        'byok': {'api_key': 'sk-your-openai-key'},\n        'expected_response_time': 2.0,  # seconds\n        'use_for': ['real_time', 'chat', 'quick_responses']\n    },\n    'balanced_performance': {\n        'provider': Providers.BEDROCK,\n        'model': Models.CLAUDE_35_SONNET,\n        'byok': None,\n        'expected_response_time': 4.0,\n        'use_for': ['production', 'balanced_tasks']\n    },\n    'high_quality': {\n        'provider': Providers.ANTHROPIC,\n        'model': 'claude-3-opus-20240229',\n        'byok': {'api_key': 'sk-ant-your-key'},\n        'expected_response_time': 8.0,\n        'use_for': ['quality_critical', 'complex_reasoning']\n    }\n}\n\n@agent.tool\ndef performance_based_routing(task: str, max_response_time: float = 5.0):\n    \"\"\"Route based on performance requirements\"\"\"\n\n    # Select fastest provider that meets quality needs\n    task_quality_needs = assess_quality_requirements(task)\n\n    suitable_providers = []\n    for name, config in PERFORMANCE_CONFIGS.items():\n        if (config['expected_response_time'] &lt;= max_response_time and\n            meets_quality_threshold(task_quality_needs, config)):\n            suitable_providers.append((name, config))\n\n    if suitable_providers:\n        # Choose fastest suitable provider\n        best_provider = min(suitable_providers, key=lambda x: x[1]['expected_response_time'])\n        return switch_to_provider(best_provider[0])\n    else:\n        return {'error': 'No provider meets performance requirements'}\n</code></pre>"},{"location":"recipes/multi-provider/#capability-optimized-setup","title":"Capability-Optimized Setup","text":"capability_optimized_config.py<pre><code># Configuration optimized for specific capabilities\nCAPABILITY_CONFIGS = {\n    'code_specialist': {\n        'provider': Providers.OPENAI,\n        'model': 'gpt-4o',\n        'byok': {'api_key': 'sk-your-openai-key'},\n        'capabilities': ['function_calling', 'code_generation', 'debugging'],\n        'use_for': ['programming', 'api_integration', 'technical_tasks']\n    },\n    'reasoning_expert': {\n        'provider': Providers.ANTHROPIC,\n        'model': 'claude-3-opus-20240229',\n        'byok': {'api_key': 'sk-ant-your-key'},\n        'capabilities': ['deep_reasoning', 'analysis', 'research', 'long_context'],\n        'use_for': ['research', 'analysis', 'complex_problem_solving']\n    },\n    'reliable_workhorse': {\n        'provider': Providers.BEDROCK,\n        'model': Models.CLAUDE_35_SONNET,\n        'byok': None,\n        'capabilities': ['reliability', 'consistency', 'safety'],\n        'use_for': ['production', 'customer_facing', 'business_critical']\n    }\n}\n\n@agent.tool\ndef capability_based_routing(task: str, required_capabilities: list):\n    \"\"\"Route based on required capabilities\"\"\"\n\n    best_match = None\n    best_score = 0\n\n    for name, config in CAPABILITY_CONFIGS.items():\n        # Calculate capability match score\n        matched_caps = set(required_capabilities) &amp; set(config['capabilities'])\n        score = len(matched_caps) / len(required_capabilities)\n\n        if score &gt; best_score:\n            best_score = score\n            best_match = name\n\n    if best_match and best_score &gt;= 0.5:  # At least 50% capability match\n        return switch_to_provider(best_match)\n    else:\n        return {'error': 'No provider has required capabilities', 'required': required_capabilities}\n</code></pre>"},{"location":"recipes/multi-provider/#monitoring-and-analytics","title":"Monitoring and Analytics","text":""},{"location":"recipes/multi-provider/#usage-dashboard","title":"Usage Dashboard","text":"<pre><code>@agent.tool\ndef get_multi_provider_dashboard(days: int = 7) -&gt; dict:\n    \"\"\"Get comprehensive dashboard of multi-provider usage\"\"\"\n\n    cutoff_date = (datetime.now() - timedelta(days=days)).date().isoformat()\n\n    # Get all usage data\n    usage_data = agent.vault.query('provider_usage', {\n        'date': {'$gte': cutoff_date}\n    })\n\n    # Get provider switches\n    switches = agent.vault.query('provider_switches', {\n        'timestamp': {'$gte': cutoff_date + 'T00:00:00'}\n    })\n\n    # Get health checks\n    health_checks = agent.vault.query('provider_health_checks', {\n        'timestamp': {'$gte': cutoff_date + 'T00:00:00'}\n    })\n\n    # Calculate metrics\n    provider_stats = {}\n    for record in usage_data:\n        provider = record['provider_name']\n        if provider not in provider_stats:\n            provider_stats[provider] = {\n                'session_count': 0,\n                'total_cost_estimate': 0,\n                'avg_response_time': 0,\n                'success_rate': 100\n            }\n        provider_stats[provider]['session_count'] += 1\n\n    # Calculate cost estimates\n    for provider, stats in provider_stats.items():\n        cost_estimate = estimate_monthly_cost(\n            [r for r in usage_data if r['provider_name'] == provider],\n            provider\n        )\n        stats['cost_estimate'] = cost_estimate\n\n    return {\n        'period_days': days,\n        'total_sessions': len(usage_data),\n        'providers_used': len(provider_stats),\n        'provider_stats': provider_stats,\n        'total_switches': len(switches),\n        'health_checks_performed': len(health_checks),\n        'cost_optimization_score': calculate_optimization_score(usage_data)\n    }\n\ndef calculate_optimization_score(usage_data: list) -&gt; float:\n    \"\"\"Calculate how well the system is optimized (0-100)\"\"\"\n\n    if not usage_data:\n        return 0\n\n    score = 50  # Base score\n\n    # Check for appropriate provider usage\n    task_provider_matches = 0\n    total_tasks = len(usage_data)\n\n    for record in usage_data:\n        task = record.get('task_description', '')\n        provider = record['provider_name']\n\n        # Simple heuristic: check if provider choice makes sense\n        task_analysis = analyze_task_requirements(task, {})\n\n        if task_analysis['complexity'] == 'low' and 'fast' in PROVIDER_CONFIGS[provider]['strengths']:\n            task_provider_matches += 1\n        elif task_analysis['complexity'] == 'high' and 'reasoning' in PROVIDER_CONFIGS[provider]['strengths']:\n            task_provider_matches += 1\n        elif task_analysis['complexity'] == 'medium':\n            task_provider_matches += 0.5\n\n    # Adjust score based on matching\n    match_rate = task_provider_matches / total_tasks\n    score += (match_rate * 50)  # Up to 50 points for good matching\n\n    return min(round(score, 1), 100)\n</code></pre>"},{"location":"recipes/multi-provider/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Stateful Agent</p> <p>Combine multi-provider capabilities with learning and memory</p> </li> <li> <p> Chatbot Agent</p> <p>Build chatbots that can switch providers based on conversation needs</p> </li> <li> <p> Automation Agent</p> <p>Create workflows that use different providers for different steps</p> </li> </ul> <p>You Built a Multi-Provider System!</p> <p>You've created an intelligent system that optimally routes tasks across multiple AI providers, balancing cost, performance, and capabilities. This gives you the flexibility to optimize for any scenario.</p> <p>Your multi-provider agent now has: \u2705 Smart Routing - Automatically selects the best provider for each task \u2705 Cost Optimization - Minimizes expenses while maintaining quality \u2705 Fallback Handling - Automatically switches providers on failures \u2705 Load Balancing - Distributes work across multiple providers \u2705 Health Monitoring - Tracks provider performance and availability \u2705 Usage Analytics - Detailed insights into costs and optimization opportunities  </p>"},{"location":"recipes/stateful-agent/","title":"Recipe: Stateful Agent with Memory","text":"<p>Build an AI agent that learns and remembers across sessions, creating personalized experiences that improve over time.</p> <p>Perfect for Personalized Applications</p> <p>This recipe shows how to build agents that remember user preferences, learn from interactions, and provide increasingly personalized responses.</p>"},{"location":"recipes/stateful-agent/#what-youll-build","title":"What You'll Build","text":"<p>A stateful agent that can:</p> <ul> <li>\ud83e\udde0 Remember user preferences and conversation history</li> <li>\ud83d\udcda Learn from interactions and improve responses over time</li> <li>\ud83d\udc64 Personalize experiences based on user behavior patterns</li> <li>\ud83d\udd04 Maintain context across multiple sessions</li> <li>\ud83d\udcca Track user journey and engagement patterns</li> <li>\ud83c\udfaf Adapt behavior based on user feedback</li> </ul>"},{"location":"recipes/stateful-agent/#the-complete-code","title":"The Complete Code","text":"learning_agent.py<pre><code>from flowstack import Agent\nfrom datetime import datetime, timedelta\nimport json\nimport statistics\n\n# Initialize the learning agent\nagent = Agent(\n    name=\"personal-learning-assistant\",\n    api_key=\"fs_your_api_key_here\",\n    system_prompt=\"\"\"You are a personal learning assistant that remembers everything about your users. You should:\n    - Remember user preferences, goals, and past conversations\n    - Learn from user feedback and adapt your responses\n    - Provide increasingly personalized and relevant help\n    - Track user progress and celebrate achievements\n    - Suggest next steps based on user patterns and history\n\n    Always check user history and preferences before responding to provide the most relevant help.\"\"\"\n)\n\n# Tool 1: User Profile Management\n@agent.tool\ndef get_user_profile(user_id: str) -&gt; dict:\n    \"\"\"Get comprehensive user profile including preferences and history\"\"\"\n\n    # Get base profile\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {\n        'user_id': user_id,\n        'created_at': datetime.now().isoformat(),\n        'preferences': {},\n        'goals': [],\n        'learning_style': 'unknown',\n        'interaction_count': 0,\n        'last_interaction': None\n    }\n\n    # Get conversation history stats\n    conversations = agent.vault.query('conversations', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=10)\n\n    # Get learning progress\n    progress = agent.vault.query('learning_progress', {\n        'user_id': user_id\n    })\n\n    # Get user feedback history\n    feedback = agent.vault.query('user_feedback', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=5)\n\n    return {\n        'profile': profile,\n        'recent_conversations': len(conversations),\n        'total_learning_items': len(progress),\n        'recent_feedback': feedback,\n        'engagement_score': calculate_engagement_score(profile, conversations, feedback)\n    }\n\ndef calculate_engagement_score(profile: dict, conversations: list, feedback: list) -&gt; float:\n    \"\"\"Calculate user engagement score based on various factors\"\"\"\n    score = 0.0\n\n    # Base score from interaction frequency\n    interaction_count = profile.get('interaction_count', 0)\n    if interaction_count &gt; 0:\n        score += min(interaction_count * 2, 50)  # Up to 50 points for interactions\n\n    # Recent activity bonus\n    if conversations:\n        latest_conversation = conversations[0]\n        days_since_last = (datetime.now() - datetime.fromisoformat(latest_conversation['timestamp'])).days\n        if days_since_last &lt; 7:\n            score += 20  # Recent activity bonus\n\n    # Feedback quality bonus\n    positive_feedback = [f for f in feedback if f.get('rating', 0) &gt;= 4]\n    if feedback:\n        feedback_ratio = len(positive_feedback) / len(feedback)\n        score += feedback_ratio * 30  # Up to 30 points for good feedback\n\n    return min(score, 100)  # Cap at 100\n\n@agent.tool\ndef update_user_preferences(user_id: str, preference_type: str, value: str, context: str = \"\") -&gt; dict:\n    \"\"\"Update user preferences with learning context\"\"\"\n\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {\n        'user_id': user_id,\n        'created_at': datetime.now().isoformat(),\n        'preferences': {},\n        'goals': [],\n        'learning_style': 'unknown',\n        'interaction_count': 0\n    }\n\n    # Update preference\n    old_value = profile['preferences'].get(preference_type)\n    profile['preferences'][preference_type] = value\n    profile['updated_at'] = datetime.now().isoformat()\n\n    # Log the preference change for learning\n    preference_change = {\n        'user_id': user_id,\n        'preference_type': preference_type,\n        'old_value': old_value,\n        'new_value': value,\n        'context': context,\n        'timestamp': datetime.now().isoformat()\n    }\n\n    agent.vault.store('preference_changes', preference_change)\n    agent.vault.store('user_profiles', profile, key=user_id)\n\n    return {\n        'message': f\"Updated {preference_type} preference to: {value}\",\n        'previous_value': old_value,\n        'context': context,\n        'learning_opportunity': old_value != value  # Did we learn something new?\n    }\n\n# Tool 2: Conversation Memory and Context\n@agent.tool\ndef save_conversation_context(user_id: str, conversation_summary: str, key_points: list, user_mood: str = \"neutral\") -&gt; dict:\n    \"\"\"Save conversation context for future reference\"\"\"\n\n    conversation = {\n        'user_id': user_id,\n        'summary': conversation_summary,\n        'key_points': key_points,\n        'user_mood': user_mood,\n        'timestamp': datetime.now().isoformat(),\n        'date': datetime.now().date().isoformat(),\n        'interaction_type': 'conversation'\n    }\n\n    conv_key = agent.vault.store('conversations', conversation)\n\n    # Update user profile interaction count\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {}\n    profile['interaction_count'] = profile.get('interaction_count', 0) + 1\n    profile['last_interaction'] = datetime.now().isoformat()\n    agent.vault.store('user_profiles', profile, key=user_id)\n\n    # Analyze conversation for learning insights\n    insights = analyze_conversation_for_insights(user_id, conversation)\n\n    return {\n        'conversation_id': conv_key,\n        'summary': conversation_summary,\n        'insights_learned': len(insights),\n        'insights': insights\n    }\n\ndef analyze_conversation_for_insights(user_id: str, conversation: dict) -&gt; list:\n    \"\"\"Analyze conversation to extract learning insights\"\"\"\n    insights = []\n\n    # Mood pattern analysis\n    mood = conversation.get('user_mood', 'neutral')\n    if mood in ['frustrated', 'confused']:\n        insights.append({\n            'type': 'mood_pattern',\n            'insight': f\"User expressed {mood} - may need simpler explanations or different approach\",\n            'action': 'adjust_communication_style'\n        })\n    elif mood in ['excited', 'satisfied']:\n        insights.append({\n            'type': 'positive_pattern',\n            'insight': f\"User was {mood} - current approach is working well\",\n            'action': 'continue_current_style'\n        })\n\n    # Key points analysis\n    key_points = conversation.get('key_points', [])\n    if 'deadline' in ' '.join(key_points).lower():\n        insights.append({\n            'type': 'urgency_pattern',\n            'insight': \"User mentioned deadline - prioritize time-sensitive responses\",\n            'action': 'flag_urgent_followups'\n        })\n\n    if any(point.lower().startswith('learn') for point in key_points):\n        insights.append({\n            'type': 'learning_intent',\n            'insight': \"User expressed learning intent - provide educational resources\",\n            'action': 'suggest_learning_materials'\n        })\n\n    return insights\n\n@agent.tool\ndef recall_relevant_context(user_id: str, current_topic: str, limit: int = 5) -&gt; dict:\n    \"\"\"Recall relevant conversation history and context for current topic\"\"\"\n\n    # Get recent conversations\n    recent_conversations = agent.vault.query('conversations', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=20)\n\n    # Filter for topic relevance (simple keyword matching - could be enhanced with embeddings)\n    relevant_conversations = []\n    topic_keywords = current_topic.lower().split()\n\n    for conv in recent_conversations:\n        conv_text = f\"{conv.get('summary', '')} {' '.join(conv.get('key_points', []))}\".lower()\n        if any(keyword in conv_text for keyword in topic_keywords):\n            relevant_conversations.append(conv)\n\n    # Get user preferences related to current topic\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {}\n    relevant_preferences = {}\n    for pref_key, pref_value in profile.get('preferences', {}).items():\n        if any(keyword in pref_key.lower() for keyword in topic_keywords):\n            relevant_preferences[pref_key] = pref_value\n\n    # Get learning progress on this topic\n    learning_progress = agent.vault.query('learning_progress', {\n        'user_id': user_id,\n        'topic': {'$regex': current_topic, '$options': 'i'}\n    })\n\n    return {\n        'current_topic': current_topic,\n        'relevant_conversations': relevant_conversations[:limit],\n        'relevant_preferences': relevant_preferences,\n        'learning_progress': learning_progress,\n        'context_items_found': len(relevant_conversations) + len(relevant_preferences) + len(learning_progress)\n    }\n\n# Tool 3: Learning Progress Tracking\n@agent.tool\ndef track_learning_progress(user_id: str, topic: str, skill_level: str, progress_notes: str) -&gt; dict:\n    \"\"\"Track user's learning progress on specific topics\"\"\"\n\n    # Check for existing progress on this topic\n    existing_progress = agent.vault.query('learning_progress', {\n        'user_id': user_id,\n        'topic': topic\n    })\n\n    if existing_progress:\n        # Update existing progress\n        progress_record = existing_progress[0]\n        old_level = progress_record.get('skill_level', 'beginner')\n        progress_record.update({\n            'skill_level': skill_level,\n            'progress_notes': progress_notes,\n            'updated_at': datetime.now().isoformat(),\n            'sessions_count': progress_record.get('sessions_count', 0) + 1\n        })\n\n        # Add to progress history\n        if 'history' not in progress_record:\n            progress_record['history'] = []\n        progress_record['history'].append({\n            'previous_level': old_level,\n            'new_level': skill_level,\n            'notes': progress_notes,\n            'timestamp': datetime.now().isoformat()\n        })\n\n        agent.vault.store('learning_progress', progress_record, key=progress_record.get('_id'))\n\n        return {\n            'topic': topic,\n            'progress_type': 'updated',\n            'old_level': old_level,\n            'new_level': skill_level,\n            'sessions_count': progress_record['sessions_count'],\n            'improvement_detected': skill_level != old_level\n        }\n    else:\n        # Create new progress record\n        progress_record = {\n            'user_id': user_id,\n            'topic': topic,\n            'skill_level': skill_level,\n            'progress_notes': progress_notes,\n            'created_at': datetime.now().isoformat(),\n            'updated_at': datetime.now().isoformat(),\n            'sessions_count': 1,\n            'history': []\n        }\n\n        progress_key = agent.vault.store('learning_progress', progress_record)\n\n        return {\n            'topic': topic,\n            'progress_type': 'new',\n            'skill_level': skill_level,\n            'progress_id': progress_key,\n            'message': f'Started tracking progress on {topic} at {skill_level} level'\n        }\n\n# Tool 4: Feedback Learning System\n@agent.tool\ndef collect_user_feedback(user_id: str, interaction_id: str, rating: int, feedback_text: str, suggestion: str = \"\") -&gt; dict:\n    \"\"\"Collect and learn from user feedback\"\"\"\n\n    feedback_record = {\n        'user_id': user_id,\n        'interaction_id': interaction_id,\n        'rating': rating,  # 1-5 scale\n        'feedback_text': feedback_text,\n        'suggestion': suggestion,\n        'timestamp': datetime.now().isoformat(),\n        'processed': False\n    }\n\n    feedback_key = agent.vault.store('user_feedback', feedback_record)\n\n    # Process feedback for learning insights\n    learning_insights = process_feedback_for_learning(user_id, feedback_record)\n\n    # Update user profile based on feedback\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {}\n\n    # Track satisfaction trends\n    if 'satisfaction_history' not in profile:\n        profile['satisfaction_history'] = []\n\n    profile['satisfaction_history'].append({\n        'rating': rating,\n        'timestamp': datetime.now().isoformat()\n    })\n\n    # Keep only last 20 ratings\n    profile['satisfaction_history'] = profile['satisfaction_history'][-20:]\n\n    # Calculate average satisfaction\n    recent_ratings = [r['rating'] for r in profile['satisfaction_history'][-10:]]\n    profile['avg_satisfaction'] = statistics.mean(recent_ratings) if recent_ratings else rating\n\n    agent.vault.store('user_profiles', profile, key=user_id)\n\n    return {\n        'feedback_id': feedback_key,\n        'rating': rating,\n        'learning_insights': learning_insights,\n        'avg_satisfaction': profile['avg_satisfaction'],\n        'satisfaction_trend': analyze_satisfaction_trend(profile['satisfaction_history'])\n    }\n\ndef process_feedback_for_learning(user_id: str, feedback: dict) -&gt; list:\n    \"\"\"Process feedback to extract learning insights\"\"\"\n    insights = []\n\n    rating = feedback.get('rating', 3)\n    feedback_text = feedback.get('feedback_text', '').lower()\n\n    # Low rating analysis\n    if rating &lt;= 2:\n        if 'too complex' in feedback_text or 'confusing' in feedback_text:\n            insights.append({\n                'type': 'communication_adjustment',\n                'insight': 'User finds responses too complex - simplify language',\n                'adjustment': 'use_simpler_language'\n            })\n\n        if 'slow' in feedback_text or 'long' in feedback_text:\n            insights.append({\n                'type': 'response_speed',\n                'insight': 'User wants faster/shorter responses',\n                'adjustment': 'provide_concise_responses'\n            })\n\n        if 'not relevant' in feedback_text or 'not helpful' in feedback_text:\n            insights.append({\n                'type': 'relevance_issue',\n                'insight': 'Response not relevant to user needs',\n                'adjustment': 'improve_context_understanding'\n            })\n\n    # High rating analysis\n    elif rating &gt;= 4:\n        if 'clear' in feedback_text or 'helpful' in feedback_text:\n            insights.append({\n                'type': 'positive_pattern',\n                'insight': 'Current communication style works well',\n                'adjustment': 'continue_current_approach'\n            })\n\n        if 'detailed' in feedback_text or 'thorough' in feedback_text:\n            insights.append({\n                'type': 'detail_preference',\n                'insight': 'User appreciates detailed responses',\n                'adjustment': 'provide_comprehensive_answers'\n            })\n\n    return insights\n\ndef analyze_satisfaction_trend(satisfaction_history: list) -&gt; str:\n    \"\"\"Analyze satisfaction trend over time\"\"\"\n    if len(satisfaction_history) &lt; 3:\n        return 'insufficient_data'\n\n    recent_ratings = [r['rating'] for r in satisfaction_history[-5:]]\n    older_ratings = [r['rating'] for r in satisfaction_history[-10:-5]] if len(satisfaction_history) &gt;= 10 else []\n\n    if not older_ratings:\n        return 'stable'\n\n    recent_avg = statistics.mean(recent_ratings)\n    older_avg = statistics.mean(older_ratings)\n\n    if recent_avg &gt; older_avg + 0.5:\n        return 'improving'\n    elif recent_avg &lt; older_avg - 0.5:\n        return 'declining'\n    else:\n        return 'stable'\n\n# Tool 5: Personalized Recommendations\n@agent.tool\ndef generate_personalized_recommendations(user_id: str, context: str = \"\") -&gt; dict:\n    \"\"\"Generate personalized recommendations based on user history and preferences\"\"\"\n\n    # Get user profile\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {}\n\n    # Get learning progress\n    learning_progress = agent.vault.query('learning_progress', {\n        'user_id': user_id\n    })\n\n    # Get recent conversations\n    recent_conversations = agent.vault.query('conversations', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=10)\n\n    # Get feedback patterns\n    feedback_history = agent.vault.query('user_feedback', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=10)\n\n    recommendations = []\n\n    # Learning path recommendations\n    if learning_progress:\n        topics_in_progress = [p['topic'] for p in learning_progress if p.get('skill_level') not in ['expert', 'advanced']]\n        for topic in topics_in_progress:\n            recommendations.append({\n                'type': 'learning_continuation',\n                'title': f'Continue learning {topic}',\n                'reason': 'You have ongoing progress in this topic',\n                'priority': 'high',\n                'topic': topic\n            })\n\n    # Based on conversation patterns\n    conversation_topics = []\n    for conv in recent_conversations:\n        conversation_topics.extend(conv.get('key_points', []))\n\n    # Find frequent topics\n    topic_frequency = {}\n    for topic in conversation_topics:\n        topic_frequency[topic] = topic_frequency.get(topic, 0) + 1\n\n    frequent_topics = sorted(topic_frequency.items(), key=lambda x: x[1], reverse=True)[:3]\n\n    for topic, frequency in frequent_topics:\n        if frequency &gt;= 2:  # Topic mentioned in multiple conversations\n            recommendations.append({\n                'type': 'interest_based',\n                'title': f'Explore more about {topic}',\n                'reason': f'You\\'ve discussed {topic} in {frequency} recent conversations',\n                'priority': 'medium',\n                'topic': topic\n            })\n\n    # Based on satisfaction trends\n    satisfaction_trend = 'stable'\n    if profile.get('satisfaction_history'):\n        satisfaction_trend = analyze_satisfaction_trend(profile['satisfaction_history'])\n\n    if satisfaction_trend == 'declining':\n        recommendations.append({\n            'type': 'experience_improvement',\n            'title': 'Let\\'s improve your experience',\n            'reason': 'Your satisfaction has been declining - let\\'s adjust my approach',\n            'priority': 'high',\n            'action': 'gather_preference_feedback'\n        })\n\n    # Time-based recommendations\n    if profile.get('last_interaction'):\n        days_since_last = (datetime.now() - datetime.fromisoformat(profile['last_interaction'])).days\n        if days_since_last &gt;= 7:\n            recommendations.append({\n                'type': 'engagement',\n                'title': 'Welcome back! Let\\'s catch up',\n                'reason': f'It\\'s been {days_since_last} days since our last conversation',\n                'priority': 'medium',\n                'action': 'status_check'\n            })\n\n    return {\n        'user_id': user_id,\n        'recommendations': recommendations,\n        'recommendation_count': len(recommendations),\n        'personalization_factors': {\n            'learning_topics': len(learning_progress),\n            'conversation_history': len(recent_conversations),\n            'satisfaction_trend': satisfaction_trend,\n            'engagement_score': calculate_engagement_score(profile, recent_conversations, feedback_history)\n        }\n    }\n\n# Tool 6: Adaptive Response Style\n@agent.tool\ndef adapt_response_style(user_id: str, message_content: str) -&gt; dict:\n    \"\"\"Adapt response style based on user history and preferences\"\"\"\n\n    # Get user preferences\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {}\n    preferences = profile.get('preferences', {})\n\n    # Get recent feedback to understand communication preferences\n    recent_feedback = agent.vault.query('user_feedback', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=5)\n\n    # Analyze feedback for communication adjustments\n    style_adjustments = []\n    for feedback in recent_feedback:\n        rating = feedback.get('rating', 3)\n        feedback_text = feedback.get('feedback_text', '').lower()\n\n        if rating &lt;= 2:\n            if 'too long' in feedback_text:\n                style_adjustments.append('be_more_concise')\n            if 'too technical' in feedback_text:\n                style_adjustments.append('use_simpler_language')\n            if 'too formal' in feedback_text:\n                style_adjustments.append('be_more_casual')\n        elif rating &gt;= 4:\n            if 'detailed' in feedback_text:\n                style_adjustments.append('provide_comprehensive_answers')\n            if 'professional' in feedback_text:\n                style_adjustments.append('maintain_formal_tone')\n\n    # Determine response style\n    response_style = {\n        'tone': preferences.get('communication_tone', 'friendly'),\n        'detail_level': preferences.get('detail_preference', 'medium'),\n        'formality': preferences.get('formality_preference', 'professional'),\n        'adjustments': list(set(style_adjustments))  # Remove duplicates\n    }\n\n    # Apply recent learning from feedback\n    if 'be_more_concise' in style_adjustments:\n        response_style['detail_level'] = 'brief'\n    if 'use_simpler_language' in style_adjustments:\n        response_style['complexity'] = 'simple'\n    if 'be_more_casual' in style_adjustments:\n        response_style['tone'] = 'casual'\n\n    return {\n        'user_id': user_id,\n        'response_style': response_style,\n        'style_source': 'learned_from_feedback' if style_adjustments else 'user_preferences',\n        'adaptations_applied': len(style_adjustments)\n    }\n\n# Test the learning agent\ndef test_learning_agent():\n    \"\"\"Test the learning agent with sample interactions\"\"\"\n    print(\"\ud83e\udde0 Testing Personal Learning Assistant\")\n    print(\"=\" * 50)\n\n    user_id = \"test_user_123\"\n\n    # Test 1: Initial interaction - should have no history\n    print(\"\\n1. First interaction (no history)...\")\n    response = agent.chat(f\"Hello! I'm new here. My user ID is {user_id}\")\n    print(f\"Agent: {response}\")\n\n    # Test 2: Set some preferences\n    print(\"\\n2. Setting user preferences...\")\n    response = agent.chat(f\"I prefer concise responses and technical explanations. My user ID is {user_id}\")\n    print(f\"Agent: {response}\")\n\n    # Test 3: Track learning progress\n    print(\"\\n3. Tracking learning progress...\")\n    response = agent.chat(f\"I'm learning Python programming and I'm at beginner level. My user ID is {user_id}\")\n    print(f\"Agent: {response}\")\n\n    # Test 4: Provide feedback\n    print(\"\\n4. Providing feedback...\")\n    response = agent.chat(f\"That was very helpful! I'd rate our conversation 5/5. My user ID is {user_id}\")\n    print(f\"Agent: {response}\")\n\n    # Test 5: Return later - should remember everything\n    print(\"\\n5. Returning user (should remember context)...\")\n    response = agent.chat(f\"Hi again! How's my Python learning progress? My user ID is {user_id}\")\n    print(f\"Agent: {response}\")\n\n    print(\"\\n\u2705 Learning agent testing complete!\")\n\n# Deploy the learning agent\ndef deploy_learning_agent():\n    \"\"\"Deploy the learning agent to production\"\"\"\n    print(\"\\n\ud83d\ude80 Deploying learning agent...\")\n\n    endpoint = agent.deploy()\n\n    print(f\"\u2705 Learning agent deployed!\")\n    print(f\"Chat endpoint: {endpoint}/chat\")\n\n    print(\"\\n\ud83e\udde0 Your agent now has:\")\n    print(\"\u2022 Memory of all user interactions\")\n    print(\"\u2022 Learning from user feedback\")\n    print(\"\u2022 Personalized recommendations\")\n    print(\"\u2022 Adaptive response styles\")\n    print(\"\u2022 Progress tracking capabilities\")\n\n    return endpoint\n\nif __name__ == \"__main__\":\n    # Run tests\n    test_learning_agent()\n\n    # Deploy\n    deploy_choice = input(\"\\nDeploy learning agent? (y/N): \")\n    if deploy_choice.lower() == 'y':\n        deploy_learning_agent()\n</code></pre>"},{"location":"recipes/stateful-agent/#advanced-learning-patterns","title":"Advanced Learning Patterns","text":""},{"location":"recipes/stateful-agent/#user-journey-mapping","title":"User Journey Mapping","text":"<pre><code>@agent.tool\ndef map_user_journey(user_id: str) -&gt; dict:\n    \"\"\"Map the user's journey and identify patterns\"\"\"\n\n    # Get all user interactions\n    conversations = agent.vault.query('conversations', {\n        'user_id': user_id\n    }, sort=[('timestamp', 1)])  # Chronological order\n\n    learning_progress = agent.vault.query('learning_progress', {\n        'user_id': user_id\n    }, sort=[('created_at', 1)])\n\n    feedback = agent.vault.query('user_feedback', {\n        'user_id': user_id\n    }, sort=[('timestamp', 1)])\n\n    # Analyze journey phases\n    journey_phases = []\n\n    if conversations:\n        # Onboarding phase (first 3 interactions)\n        onboarding_convs = conversations[:3]\n        onboarding_phase = {\n            'phase': 'onboarding',\n            'duration_days': calculate_phase_duration(onboarding_convs),\n            'interaction_count': len(onboarding_convs),\n            'key_topics': extract_topics_from_conversations(onboarding_convs)\n        }\n        journey_phases.append(onboarding_phase)\n\n        # Growth phase (active learning period)\n        if len(conversations) &gt; 3:\n            growth_convs = conversations[3:]\n            growth_phase = {\n                'phase': 'growth',\n                'duration_days': calculate_phase_duration(growth_convs),\n                'interaction_count': len(growth_convs),\n                'learning_topics': len(learning_progress),\n                'avg_satisfaction': calculate_avg_satisfaction_for_period(feedback)\n            }\n            journey_phases.append(growth_phase)\n\n    # Identify engagement patterns\n    engagement_patterns = analyze_engagement_patterns(conversations)\n\n    return {\n        'user_id': user_id,\n        'journey_phases': journey_phases,\n        'engagement_patterns': engagement_patterns,\n        'total_interactions': len(conversations),\n        'learning_topics_explored': len(learning_progress),\n        'journey_insights': generate_journey_insights(journey_phases, engagement_patterns)\n    }\n\ndef calculate_phase_duration(conversations: list) -&gt; int:\n    \"\"\"Calculate duration of a phase in days\"\"\"\n    if len(conversations) &lt; 2:\n        return 0\n\n    start_date = datetime.fromisoformat(conversations[0]['timestamp'])\n    end_date = datetime.fromisoformat(conversations[-1]['timestamp'])\n    return (end_date - start_date).days\n\ndef extract_topics_from_conversations(conversations: list) -&gt; list:\n    \"\"\"Extract key topics from conversations\"\"\"\n    all_topics = []\n    for conv in conversations:\n        all_topics.extend(conv.get('key_points', []))\n\n    # Count frequency and return top topics\n    topic_freq = {}\n    for topic in all_topics:\n        topic_freq[topic] = topic_freq.get(topic, 0) + 1\n\n    return sorted(topic_freq.items(), key=lambda x: x[1], reverse=True)[:5]\n\ndef analyze_engagement_patterns(conversations: list) -&gt; dict:\n    \"\"\"Analyze user engagement patterns\"\"\"\n    if not conversations:\n        return {}\n\n    # Calculate time between interactions\n    intervals = []\n    for i in range(1, len(conversations)):\n        prev_time = datetime.fromisoformat(conversations[i-1]['timestamp'])\n        curr_time = datetime.fromisoformat(conversations[i]['timestamp'])\n        intervals.append((curr_time - prev_time).days)\n\n    # Identify patterns\n    patterns = {\n        'avg_days_between_interactions': statistics.mean(intervals) if intervals else 0,\n        'most_active_period': find_most_active_period(conversations),\n        'consistency_score': calculate_consistency_score(intervals)\n    }\n\n    return patterns\n\ndef find_most_active_period(conversations: list) -&gt; str:\n    \"\"\"Find the most active period for the user\"\"\"\n    if not conversations:\n        return 'no_data'\n\n    # Group by week\n    weekly_counts = {}\n    for conv in conversations:\n        date = datetime.fromisoformat(conv['timestamp']).date()\n        week_start = date - timedelta(days=date.weekday())\n        weekly_counts[week_start] = weekly_counts.get(week_start, 0) + 1\n\n    if not weekly_counts:\n        return 'no_data'\n\n    most_active_week = max(weekly_counts.items(), key=lambda x: x[1])\n    return f\"Week of {most_active_week[0]} ({most_active_week[1]} interactions)\"\n</code></pre>"},{"location":"recipes/stateful-agent/#predictive-insights","title":"Predictive Insights","text":"<pre><code>@agent.tool\ndef predict_user_needs(user_id: str) -&gt; dict:\n    \"\"\"Predict what the user might need based on patterns\"\"\"\n\n    # Get user data\n    profile = agent.vault.retrieve('user_profiles', key=user_id) or {}\n    conversations = agent.vault.query('conversations', {\n        'user_id': user_id\n    }, sort=[('timestamp', -1)], limit=20)\n\n    learning_progress = agent.vault.query('learning_progress', {\n        'user_id': user_id\n    })\n\n    predictions = []\n\n    # Predict based on learning progress\n    for progress in learning_progress:\n        topic = progress['topic']\n        skill_level = progress['skill_level']\n        last_update = datetime.fromisoformat(progress['updated_at'])\n        days_since_update = (datetime.now() - last_update).days\n\n        if skill_level == 'beginner' and days_since_update &gt; 7:\n            predictions.append({\n                'type': 'learning_support',\n                'prediction': f'User may need encouragement to continue learning {topic}',\n                'confidence': 0.8,\n                'suggested_action': 'offer_practice_exercises'\n            })\n        elif skill_level == 'intermediate' and days_since_update &gt; 14:\n            predictions.append({\n                'type': 'advancement_opportunity',\n                'prediction': f'User ready for advanced {topic} concepts',\n                'confidence': 0.7,\n                'suggested_action': 'suggest_advanced_topics'\n            })\n\n    # Predict based on conversation patterns\n    if conversations:\n        recent_moods = [c.get('user_mood', 'neutral') for c in conversations[:5]]\n        frustrated_count = recent_moods.count('frustrated')\n\n        if frustrated_count &gt;= 2:\n            predictions.append({\n                'type': 'support_needed',\n                'prediction': 'User showing signs of frustration - may need different approach',\n                'confidence': 0.9,\n                'suggested_action': 'adjust_teaching_style'\n            })\n\n        # Check for declining engagement\n        interaction_gaps = []\n        for i in range(1, min(5, len(conversations))):\n            gap = (datetime.fromisoformat(conversations[i-1]['timestamp']) - \n                  datetime.fromisoformat(conversations[i]['timestamp'])).days\n            interaction_gaps.append(gap)\n\n        if interaction_gaps and statistics.mean(interaction_gaps) &gt; 7:\n            predictions.append({\n                'type': 'engagement_risk',\n                'prediction': 'User engagement declining - may need re-engagement',\n                'confidence': 0.7,\n                'suggested_action': 'send_check_in_message'\n            })\n\n    return {\n        'user_id': user_id,\n        'predictions': predictions,\n        'prediction_count': len(predictions),\n        'generated_at': datetime.now().isoformat()\n    }\n</code></pre>"},{"location":"recipes/stateful-agent/#integration-examples","title":"Integration Examples","text":""},{"location":"recipes/stateful-agent/#progressive-web-app-integration","title":"Progressive Web App Integration","text":"learning_app.js<pre><code>class LearningAssistant {\n    constructor(apiKey, endpoint) {\n        this.apiKey = apiKey;\n        this.endpoint = endpoint;\n        this.userId = this.getUserId();\n    }\n\n    async sendMessage(message) {\n        const response = await fetch(`${this.endpoint}/chat`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-API-Key': this.apiKey\n            },\n            body: JSON.stringify({\n                message: `${message} (user_id: ${this.userId})`,\n                context: {\n                    platform: 'web_app',\n                    session_id: this.getSessionId()\n                }\n            })\n        });\n\n        return await response.json();\n    }\n\n    async trackLearningProgress(topic, level, notes) {\n        return await this.sendMessage(\n            `Track my learning progress: Topic: ${topic}, Level: ${level}, Notes: ${notes}`\n        );\n    }\n\n    async provideFeedback(interactionId, rating, feedback) {\n        return await this.sendMessage(\n            `Feedback for interaction ${interactionId}: Rating: ${rating}/5, Feedback: ${feedback}`\n        );\n    }\n\n    async getPersonalizedRecommendations() {\n        return await this.sendMessage(\n            'What would you recommend for me to learn or explore next?'\n        );\n    }\n\n    getUserId() {\n        // Get or generate user ID\n        let userId = localStorage.getItem('learning_user_id');\n        if (!userId) {\n            userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n            localStorage.setItem('learning_user_id', userId);\n        }\n        return userId;\n    }\n\n    getSessionId() {\n        // Generate session ID for this browser session\n        if (!this.sessionId) {\n            this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n        }\n        return this.sessionId;\n    }\n}\n\n// Usage example\nconst assistant = new LearningAssistant('fs_your_api_key', 'https://api.flowstack.fun/agents/personal-learning-assistant');\n\n// Track a learning session\nassistant.trackLearningProgress('JavaScript', 'intermediate', 'Completed async/await tutorial');\n\n// Get personalized recommendations\nassistant.getPersonalizedRecommendations().then(response =&gt; {\n    console.log('Recommendations:', response);\n});\n</code></pre>"},{"location":"recipes/stateful-agent/#next-steps","title":"Next Steps","text":"<ul> <li> <p> Multi-Provider Setup</p> <p>Optimize costs and capabilities across different AI providers</p> </li> <li> <p> Chatbot Agent</p> <p>Build conversational interfaces with memory and learning</p> </li> <li> <p> Automation Agent</p> <p>Create intelligent workflows that remember and adapt</p> </li> </ul> <p>You Built a Learning Agent!</p> <p>You've created an AI agent that truly learns and adapts to each user. Unlike traditional chatbots that forget everything after each conversation, your agent builds deeper relationships and provides increasingly personalized experiences.</p> <p>Your learning agent now has: \u2705 Persistent Memory - Remembers everything about each user \u2705 Feedback Learning - Improves responses based on user ratings \u2705 Progress Tracking - Monitors user learning and growth \u2705 Predictive Insights - Anticipates user needs \u2705 Adaptive Communication - Adjusts style based on preferences \u2705 Journey Mapping - Understands user patterns over time  </p>"}]}